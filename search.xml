<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>13-算法</title>
      <link href="/2024/12/06/13-%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/06/13-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="13-算法-软件设计师"><a href="#13-算法-软件设计师" class="headerlink" title="13. 算法 - 软件设计师"></a>13. 算法 - 软件设计师</h2><p><strong>回溯法</strong>：</p><ul><li><p>深度优先</p></li><li><p>N 皇后问题：在 N×N 的棋盘上摆放 N 个皇后，并且满足 N 个皇后中任意两个皇后都不处于同一行、同一列、同一斜线（正斜线、反斜线）上，，对于皇后 $Q_i$ 和皇后 $Q_j$ ：</p><ul><li>判断是否位于同一列：<script type="math/tex">Q_{i列}=Q_{j列}</script></li><li>判断是否位于同一斜线：<script type="math/tex">|Q_{i行}-Q_{j行}|=|Q_{i列}-Q_{j列}|</script></li></ul><blockquote><p>对于下图，方案 1：2,4,1,3 方案 2：3,1,4,2 数字表示当前皇后位于第几列</p></blockquote><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/N皇后问题.gif" alt="image-202410122142" style="zoom: 50%;"></p></li></ul><p><strong>分治法</strong>：分解 → 求解 → 合并</p><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/分治法.gif" alt="image-202410131103" style="zoom: 80%;"></p><ul><li><p>归并排序（递归）：由</p><script type="math/tex; mode=display">T(n)=\left\{    \begin{array}{l}        O(1)\qquad\qquad\qquad n\leq{1} \\        2T(\frac{n}{2})+O(n)\qquad n>1    \end{array}\right.</script><p>解得 $T(n)=O(nlogn)$</p></li><li><p>最大子段和：序列中所有整数均为负整数时，其最大字段和为 0</p></li></ul><p><strong>动态规划</strong>：全局最优解，① 最优子结构 ② 重叠子问题</p><ul><li><p>0-1 背包问题：有 $N$ 个物品，第 $i$ 个物品价值为 $v_i$，重量为 $w_i$，背包容量为 $W$（均为非负数），现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大</p><p>时间复杂度和空间复杂度：$O(N\times{M})$</p><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/微信截图_20241013154718.png" alt="微信截图_20241013154718"></p></li><li><p>最长上升公共子序列</p></li><li><p>矩阵连乘：时间复杂度 → $O(n^3)$ 空间复杂度 → $O(n^2)$</p><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/image-20241013165525938.png" alt="image-20241013165525938" style="zoom: 33%;"></p><blockquote><p>技巧：优先消除大的数</p><ol><li>$M_2\times{M_3}=(5\times{35})\times(35\times{4})\rightarrow{5\times{4}}$，消除最大的 35</li><li>$M_1\times(M_2\times{M_3})=(20\times{5})\times(5\times{4})\rightarrow{20\times{4}}$，消除 5 和 4 中较大的 5</li><li>$(M_1\times(M_2\times{M_3}))\times{M_4}=(20\times{4})\times(4\times{25})\rightarrow{20\times{25}}$</li><li>故选 C</li></ol><p>四个矩阵$M_1$、$M_2$、$M_3$、$M_4$ 相乘的维度序列为 2、6、3、10、3，则：</p><ul><li>$M_1=2\times{6}$ 、$M_2=6\times{3}$ 、$M_3=3\times{10}$ 、$M_4=10\times{3}$</li><li>结果：<script type="math/tex">M_1\times{M_2}\rightarrow(M_1\times{M_2})_{2\times{3}}</script>（约去 6）</li><li>乘法次数：$(M_1\times{M_2})\times(M_3\times{M_4})=2\times{6}\times{3}+3\times{10}\times{3}+2\times{3}\times{3}=144$</li></ul><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/image-20241013172837294.png" alt="image-20241013172837294" style="zoom:50%;"></p></blockquote></li></ul><p><strong>贪心法</strong>：局部最优解，① 最优子结构 ② 贪心选择性质</p><ul><li><p>部分背包问题：有 n=5 个物品，背包容量为 W=100，可以装一部分到背包中</p><p>时间复杂度：$O(nlog_2n)$，度量标准：</p><ul><li>按最大价值先放背包的原则</li><li>按最小重量先放背包原则</li><li>按最大单位重量价值先放背包的原则（最优解）</li></ul><p><img src="/2024/12/06/13-%E7%AE%97%E6%B3%95/image-20241013202043315.png" alt="image-20241013202043315" style="zoom:50%;"></p></li><li><p>活动选择</p></li></ul><p><strong>分支限界法</strong>：</p><ul><li>广度优先</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-数据结构</title>
      <link href="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="12-数据结构-软件设计师"><a href="#12-数据结构-软件设计师" class="headerlink" title="12. 数据结构 - 软件设计师"></a>12. 数据结构 - 软件设计师</h2><p><strong>大 O 表示法</strong>：</p><script type="math/tex; mode=display">O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p>​ 常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 指数阶 阶乘阶 n 次方阶</p><ul><li>加法规则：多项相加，保留最高阶项，并将系数化为 1</li><li>乘法规则：多项相乘都保留，并将系数化为 1</li><li>加法乘法混合规则：先小括号再乘法规则，最后加法规则</li></ul><blockquote><p>示例：<script type="math/tex">T(n)=(2n+3)\times{(3n^2+4)}\rightarrow n\times{n^2}\rightarrow O(n^3)</script></p></blockquote><p><strong>渐进符号</strong>：</p><ul><li>O 记号，渐进上界，<script type="math/tex">O(g(n))\geq{f(n)}</script></li><li>‌Ω 记号，渐进下界，<script type="math/tex">Ω(g(n))\leq{f(n)}</script></li><li>‌Θ 记号，渐进紧致界，当且仅当<script type="math/tex">O(g(n))=f(n)</script> 和 <script type="math/tex">Ω(g(n))=f(n)</script> 时，<script type="math/tex">Θ(g(n))=f(n)</script></li></ul><blockquote><p>示例：</p><p><script type="math/tex">10n^2+4n+2=O(n^3)</script> ——&gt; √</p><p><script type="math/tex">10n^2+4n+2=O(n)</script> ——&gt; ×</p><p><script type="math/tex">10n^2+4n+2=Ω(n)</script> ——&gt; √</p><p><script type="math/tex">10n^2+4n+2=Ω(n^3)</script> ——&gt; ×</p><p><script type="math/tex">10n^2+4n+2=Θ(n^2)</script> ——&gt; √</p><p><script type="math/tex">10n^2+4n+2=Θ(n)或Θ(n^3)</script> ——&gt; ×</p></blockquote><p><strong>递归</strong>：</p><p>$递归式时间复杂度=递归次数\times{每次递归的时间复杂度}$（每次递归的时间复杂度不变的情况）</p><p>递归式主方法：<script type="math/tex">T(n)=aT(\frac{n}{b})+f(n)</script>，其中 a≥1 和 b&gt;1 是常数，f(n)是一个渐进的正函数</p><ul><li>若对于某常数 <script type="math/tex">ε>0，有 f(n)=O(n^{log*{b}a+ε})，则 T(n)=Θ(n^{log*{b}a})</script></li><li>若<script type="math/tex">f(n)=Θ(n^{log*{b}a}lg^{k}n)，则 T(n)=Ω(n^{log*{b}a}lg^{k+1}n)</script></li></ul><p><strong>线性结构</strong>：</p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ul><li><p>顺序存储：</p><ul><li><p>等概率下 <strong>_____</strong> 需要移动的元素个数期望值</p><p>插入一个新元素：<script type="math/tex">E*{insert}=\sum*{i=1}^{n+1}P*{i}\times{(n-i+1)}=\frac{1}{n+1}\sum*{i=1}^{n+1}(n-i+1)=\frac{n}{2}</script></p><p>删除元素：<script type="math/tex">E*{delete}=\sum*{i=1}^{n}q*{i}\times{(n-i)}=\frac{1}{n}\sum*{i=1}^{n}(n-i)=\frac{n-1}{2}</script></p></li><li><p>时间复杂度：</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">最好</th><th style="text-align:center">最坏</th><th style="text-align:center">平均</th></tr></thead><tbody><tr><td style="text-align:center">插入</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr></tbody></table></div><ul><li><p>链式存储</p><ul><li><p>数据域用于存储数据元素的值，指针域用于存储当前元素的直接前驱或直接后驱的位置信息</p></li><li><p>时间复杂度：</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">最好</th><th style="text-align:center">最坏</th><th style="text-align:center">平均</th></tr></thead><tbody><tr><td style="text-align:center">插入</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">查找</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td></tr></tbody></table></div><ul><li><p>栈：后进先出的线性表</p><p>进行插入和删除操作的一端称为栈顶，另一端称为栈底，不含数据元素的栈称为空栈</p></li><li><p>队列：先进先出的线性表</p><p>允许插入元素的一端称为队尾，允许删除元素的一端称为队头</p><p>循环队列的优点：入队和出队操作不需要移动队列中的其他元素</p></li><li><p>串：仅由字符构成的有限序列</p><p>空串 → 长度为 0 的串，不包含任何字符</p><p>空格串 → 由一个或多个空格组成的串，有长度</p><p>子串 → 由串中任意长度的连续字符构成的序列，空串是任意串的子串</p><p>串比较：从两个串的第一个字符开始进行，字符的码值大者所在的串为大，若其中一个串先结束，则以串长较大者为大</p><ul><li><p>朴素模式匹配：时间复杂度最好<script type="math/tex">O(m)</script>，最坏<script type="math/tex">O(n×m)</script>，平均<script type="math/tex">O(n+m)</script></p></li><li><p>kmp 算法</p><p>串的前缀：包含第一个字符并且不包含最后一个字符的子串</p><p>串的后缀：包含最后一个字符并且不包含第一个字符的子串</p><p>第 i 个字符的 next 值 = 从 1 ~ i-1 串中最长相等前后缀长度 + 1</p><p>特殊情况：next[1]=0 next[2]=1</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241010133322779.png" alt="image-20241010133322779" style="zoom: 50%;"></p></li></ul></li></ul><p><strong>数组</strong>：</p><ul><li><p>一维数组</p><p>下标从 0 开始：<script type="math/tex">a_i=LOC+i\times{L}</script></p><p>下标从 1 开始：<script type="math/tex">a_i=LOC+(i-1)\times{L}</script></p></li><li><p>二维数组</p><p>按行优先存储</p><ul><li>下标从 0 开始：<script type="math/tex">a_{i,j}=LOC+(i\times{M}+j)\times{L}</script></li><li>下标从 1 开始：<script type="math/tex">a_{i,j}=LOC+[(i-1)\times{M}+(j-1)]\times{L}</script></li></ul><p>按列优先存储</p><ul><li>下标从 0 开始：<script type="math/tex">a_{i,j}=LOC+(j\times{N}+i)\times{L}</script></li><li>下标从 1 开始：<script type="math/tex">a_{i,j}=LOC+[(j-1)\times{N}+(i-1)]\times{L}</script></li></ul></li></ul><blockquote><p>LOC：第一个元素的首地址 N：行数 M：列数 L：元素大小</p></blockquote><p><strong>矩阵</strong>：</p><ul><li><p>对称矩阵</p><ul><li><p>按行存储下三角区和主对角线并且下标从 0（A~0,0~）开始</p><p>当 <script type="math/tex">i\geq{j}</script> 时：<script type="math/tex">A_{i,j}=\frac{i(i+1)}{2}+j+1</script></p><p>当 <script type="math/tex">i\leq{j}</script> 时：<script type="math/tex">A_{i,j}=\frac{j(j+1)}{2}+i+1</script></p></li><li><p>按行存储下三角区和主对角线并且下标从 1（A~1,1~）开始</p><p>当 <script type="math/tex">i\geq{j}</script> 时，<script type="math/tex">A_{i,j}=\frac{i(i-1)}{2}+j</script></p><p>当 <script type="math/tex">i\leq{j}</script> 时，<script type="math/tex">A_{i,j}=\frac{j(j-1)}{2}+i</script></p></li></ul></li><li><p>三对角矩阵</p><p>按行存储并且下标从 0（A~0,0~）开始：<script type="math/tex">A_{i,j}=2i+j+1</script></p><p>按行存储并且下标从 1（A~1,1~）开始：<script type="math/tex">A_{i,j}=2i+j-2</script></p></li><li><p>稀疏矩阵：进行压缩存储的方式 → 三元组顺序表、十字链表</p></li></ul><p><strong>树</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A((A))---B((B))</span><br><span class="line">A((A))---C((C))</span><br><span class="line">A((A))---D((D))</span><br><span class="line">B((B))---E((E))</span><br><span class="line">B((B))---F((F))</span><br><span class="line">D((D))---G((G))</span><br></pre></td></tr></table></figure><ul><li>双亲结点即是父结点；具有相同双亲的结点为兄弟结点（B、C、D）</li><li>结点的度：一个结点的子树的个数（A 的度为 3，B 的度为 2）</li><li>叶子结点：终端结点，即度为 0 的结点（E、F、C、G）</li><li>分支结点：度不为 0 的结点（B、D）</li><li>结点的层次：根为第 1 层，根的孩子为第 2 层，以此类推（A 在第 1 层，BCD 在第 2 层，EFG 在第 3 层）</li><li>树的高度：一棵树的最大层数（上图树的高度为 3）</li></ul><blockquote><p>性质 1：<script type="math/tex">树中的结点总数=树中所有结点的度数之和+1</script></p><p>性质 2：度为 m 的树中第 i 层上至多有 <script type="math/tex">m^{i-1}</script> 个结点（ <script type="math/tex">i\geq1</script>）</p><p>性质 3：高度为 h 的 m 次树（度为 m 的树）至多有 <script type="math/tex">\frac{m^h-1}{m-1}</script> 个结点</p><p>性质 4：具有 n 个结点、度为 m 的树的最小高度为 <script type="math/tex">\lceil{log_m(n(m-1)+1)}\rceil</script>（向上取整）</p></blockquote><p><strong>二叉树</strong>：二叉树结点最大度为 2</p><p>满二叉树：深度为 k 且有 <script type="math/tex">2^k-1</script> 个结点</p><p>完全二叉树：深度为 k、有 n 个结点的二叉树，其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241010201852960.png" alt="image-20241010201852960" style="zoom:50%;"></p><ul><li>二叉树第 <script type="math/tex">i</script> 层（<script type="math/tex">i\geq{1}</script>）上最多有 <script type="math/tex">2^{i-1}</script> 个结点</li><li>高度为 <script type="math/tex">h</script> 的二叉树最多有 <script type="math/tex">2^h-1</script> 个结点</li><li>对于任何一棵二叉树，<script type="math/tex">度为0的结点数=度为2的结点数+1</script></li><li>具有 <script type="math/tex">n</script> 个结点的完全二叉树的高度为 <script type="math/tex">\lfloor{log_2n}\rfloor+1</script>（向下取整） 或 <script type="math/tex">\lceil{log_2(n+1)}\rceil</script>（向上取整）</li></ul><blockquote><p>具有 n 个结点的二叉树有 <script type="math/tex">\frac{C^{n}_{2n}}{n+1}</script> 种（<script type="math/tex">C^{m}_{n}=\frac{n!}{m!\times{(n-m)!}}</script>）</p></blockquote><ul><li><p>顺序存储：二叉树有 $n$ 个结点，对于编号为 $i$ 的结点</p><ul><li>$i=1$时为根节点；$i&gt;1$ 时，该结点的双亲结点为 $\lfloor{i/2}\rfloor$</li><li>若 <script type="math/tex">2i\leq{n}</script>，该结点的左孩子编号为 <script type="math/tex">2i</script>，否则无左孩子</li><li>若 <script type="math/tex">2i+1\leq{n}</script>，该结点的右孩子编号为 <script type="math/tex">2i+1</script>，否则无右孩子</li><li>最坏情况下，一个深度为 <script type="math/tex">k</script> 且只有 <script type="math/tex">k</script> 个结点的二叉树（单支树）需要 <script type="math/tex">2^k-1</script> 个存储单元</li></ul></li><li><p>链式存储：二叉树有 <script type="math/tex">n</script> 个结点，则有 <script type="math/tex">n-1</script> 个分支</p><ul><li><p>二叉链表：<script type="math/tex">2n</script> 个指针域，其中有效指针域为 <script type="math/tex">n-1</script> 个，空指针域为 <script type="math/tex">n+1</script> 个</p></li><li><p>三叉链表：<script type="math/tex">3n</script> 个指针域，其中有效指针域为 <script type="math/tex">2n-2</script> 个，空指针域为 <script type="math/tex">n+2</script> 个</p></li></ul></li></ul><p>先序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p>层序遍历：从第 1 层到第 h 层，每层从左到右访问所有结点</p><blockquote><p>构造二叉树：中序+先序/后序/层序 → 先序/后序/层序找根，中序辨左右</p></blockquote><p>平衡二叉树：二叉树中的任意一个结点的左右子树高度之差的绝对值不超过 1</p><p>二叉排序树：根节点的关键字大于左子树所有结点的关键字，小于右子树所有结点的关键字，左右子树也是二叉排序树，中序遍历得到的是有序序列</p><p>最优二叉树（哈夫曼树）：带权路径长度最短的树，路径上的分支数目称为路径长度</p><p>带权路径长度之和：<script type="math/tex">WPL=\sum^{n}_{k=1}w_kl_k</script>（<script type="math/tex">n</script>为带权叶子结点数目，<script type="math/tex">w_k</script>为权值，<script type="math/tex">l_k</script>为叶子节点到根的路径长度）</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241011110733136.png" alt="image-20241011110733136" style="zoom:50%;"></p><p>构造最优二叉树：</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241011121835318.png" alt="image-20241011121835318" style="zoom:50%;"></p><blockquote><p>固定长度编码：<script type="math/tex">2^{固定长度}\geq{字符个数}</script></p></blockquote><p>线索二叉树：与普通二叉树相同，只是改变了存储结构，一般为干扰选项</p><blockquote><p>具有 n 个结点的二叉树有 <script type="math/tex">\frac{C^n_{2n}}{n+1}</script> 种 （卡特兰数）</p></blockquote><p><strong>图</strong>：</p><ul><li><p>有向图：每条边都是有方向的，顶点之间的关系用&lt;<script type="math/tex">v_i,v_j</script>&gt;表示，<script type="math/tex">v_i</script>为起点（弧尾），<script type="math/tex">v_j</script>为终点（弧头）</p></li><li><p>无向图：每条边都是无方向的，顶点之间的关系用 <script type="math/tex">(v_i,v_j)</script>或 <script type="math/tex">(v_j,v_i)</script> 表示</p></li><li><p>完全图：对于有 n 个顶点的图</p><ul><li>完全无向图：每一个顶点与其他 <script type="math/tex">n-1</script> 个顶点之间都有边，共有 <script type="math/tex">\frac{n(n-1)}{2}</script> 条边</li><li>有向完全图：任意两个不同顶点之间都有方向相反的两条弧存在，共有 <script type="math/tex">n(n-1)</script> 条弧</li></ul></li><li><p>度：顶点 <script type="math/tex">v</script> 的度是指关联于该顶点的边的数目，有向图顶点的度等于该顶点的入度和出度之和</p><ul><li>出度：以该顶点为起点的有向边的数目</li><li>入度：以该顶点为终点的有向边的数目</li></ul><p>顶点数 <script type="math/tex">n</script>，边数 <script type="math/tex">e</script> 与各顶点的度之间的关系：<script type="math/tex">e=\frac{1}{2}\sum^{n}_{i=1}D(v_i)</script></p></li><li><p>路径：从顶点 <script type="math/tex">v_p</script> 到顶点 <script type="math/tex">v_q</script>，路径长度是路径上边或弧的数目</p><ul><li>回路或环：第一个顶点和最后一个顶点相同的路径</li><li>简单路径：一条路径上除了 <script type="math/tex">v_p</script> 和 <script type="math/tex">v_q</script> 可以相同外，其余顶点均不相同</li></ul></li><li><p>连通图：无向图中任意两个顶点都是连通的；边数最少为 <script type="math/tex">n-1</script>，最多为 <script type="math/tex">\frac{n(n-1)}{2}</script></p></li><li><p>强连通图：有向图中每对顶点之间存在路径（<script type="math/tex">v_i\rightarrow{v_j}</script>和<script type="math/tex">v_j\rightarrow{v_i}</script>）；边数最少为 <script type="math/tex">n</script>，最多为 <script type="math/tex">n(n-1)</script></p></li><li><p>邻接矩阵：无向图的邻接矩阵是对称的；非 0 元素个数，有向图 → e 个，无向图 → 2e 个</p><ul><li>无向图中，顶点 <script type="math/tex">v_i</script> 的度是邻接矩阵第 <script type="math/tex">i</script> 行（或列）中值不为 0 的元素个数</li><li>有向图中，第 <script type="math/tex">i</script> 行中非 0 元素个数是顶点 <script type="math/tex">v_i</script> 的出度，第 <script type="math/tex">j</script> 列的非 0 元素个数是顶点 <script type="math/tex">v_j</script> 的入度</li></ul></li><li><p>邻接链表：边数为 e，有向图 → <script type="math/tex">表结点个数=e</script>，无向图 → <script type="math/tex">表结点个数=2e</script></p></li><li><p>网：边（或弧）带权值的图</p></li></ul><blockquote><p>稠密图，边多（完全图） → 邻接矩阵 稀疏图，边少 → 邻接表</p></blockquote><p>深度优先遍历（DFS）：栈+递归，邻接矩阵 → <script type="math/tex">O(n^2)</script> 邻接表 → <script type="math/tex">O(n+e)</script></p><p>广度优先遍历（BFS）：队列，邻接矩阵 → <script type="math/tex">O(n^2)</script> 邻接表 → <script type="math/tex">O(n+e)</script></p><p><strong>拓扑排序</strong>：AOV 网 → 有向无环图</p><ul><li>在 AOV 网中选择一个入度为 0（没有前驱）的顶点且输出它</li><li>从网中删除该顶点及与该顶点有关的所有弧</li><li>重复上述两步，直到网中不存在入度为 0 的顶点为止</li></ul><blockquote><p>在有向无环图 G 的拓扑序列中，顶点 <script type="math/tex">v_i</script> 在 <script type="math/tex">v_j</script> 之前，则：</p><ul><li>可能存在弧 &lt;<script type="math/tex">v_i,v_j</script>&gt; ，一定不存在弧度 &lt;<script type="math/tex">v_j,v_i</script>&gt;</li><li>可能存在 <script type="math/tex">v_i</script> 到 <script type="math/tex">v_j</script> 的路径，一定不存在 <script type="math/tex">v_j</script> 到 <script type="math/tex">v_i</script> 的路径</li></ul></blockquote><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241012090922611.png" alt="image-20241012090922611" style="zoom:50%;"></p><p><strong>查找</strong>：</p><ul><li><p>静态查找表：</p><ul><li><p>顺序查找：适用于顺序存储和链式存储，不需要元素有序</p><p>平均查找长度：<script type="math/tex">ASL*{ss}=\sum^{n}*{i=1}P*iC_i=\frac{1}{n}\sum^{n}*{i=1}(n-i+1)=\frac{n+1}{2}</script></p><blockquote><p><script type="math/tex">P_i</script> 为对表中第 <script type="math/tex">i</script> 个记录进行查找的概率，<script type="math/tex">C_i</script> 为找到第 <script type="math/tex">i</script> 个记录时已进行过比较的关键字个数</p></blockquote></li><li><p>折半（二分）查找：适用于顺序存储，元素有序排列</p><p>最多比较次数：<script type="math/tex">\lfloor{log_2n}\rfloor+1</script> 次</p><p>平均查找长度：<script type="math/tex">ASL*{bs}=\sum^{n}*{j=1}P*iC_i=\frac{1}{n}\sum^{n}*{j=1}j\times{2^{j-1}}=\frac{n+1}{n}log_2(n+1)-1</script></p><blockquote><p>当 n 值较大时，<script type="math/tex">ASL_{bs}\approx{log_2(n+1)-1}</script></p></blockquote><p>平均查找长度：查找成功 → <script type="math/tex">\frac{\sum^{n}_{i=1}(i\times{第 i 层结点数})}{总结点数}</script> 查找失败 → <script type="math/tex">\frac{\sum^{n}_{i=1}[(i-1)\times{第 i 层的外结点数}]}{外结点总数}</script></p><p>平均比较次数：</p><ul><li>查找成功 → <script type="math/tex">\frac{\sum^n*{i=1}(第 i 层的比较次数\times{第 i 层的结点数})}{总节点数}</script> 查找失败 → <script type="math/tex">\frac{\sum^n*{i=1}(第 i 层比较次数\times{第 i 层的外结点数})}{总外节点数}</script></li></ul><blockquote><p>对于下面的树，位于第 <script type="math/tex">i</script> 层即为需要比较 <script type="math/tex">i</script> 次</p><p>图中红色结点即为外结点（为空），<script type="math/tex">外结点总数=结点数+1</script></p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241015155811423.png" alt="image-20241015155811423" style="zoom:50%;"></p></blockquote></li><li><p>分块查找</p></li></ul></li><li><p>动态查找表：</p><ul><li><p>二叉排序树</p></li><li><p>平衡二叉树</p></li><li><p>B-树</p></li><li><p>哈希表：冲突只能尽可能减少而不能完全避免</p><p>具有相同哈希函数值的关键字对该哈希函数来说称为同义词</p><ul><li><p>哈希函数：除留余数法，尽可能使关键字的所有组成部分都能起作用</p></li><li><p>处理冲突：开放定址法 → <script type="math/tex">H_i=(H(key)+d_i)\bmod{m}</script>，m 为表长，<script type="math/tex">d_i</script> 为增量序列</p><blockquote><p>① <script type="math/tex">d_i=1,2,3,...,m-1</script>，称为线性探测法</p><p>② <script type="math/tex">d_i=1^2,-1^2,2,-2^2,3,-3^2,...,\pm{k^2}</script>（<script type="math/tex">k\leq{\frac{m}{2}}</script>），称为二次探测法</p></blockquote><p>链地址法 → 发生冲突的记录链接在一个链表内</p></li><li><p>装填因子：<script type="math/tex">\alpha=\frac{表中装入的记录数}{哈希表的长度}</script></p><blockquote><p><script type="math/tex">\alpha</script> 越小，发生冲突的可能性越小，反之亦然</p></blockquote></li></ul></li></ul></li></ul><p><strong>堆</strong>：n 个关键码构成的序列 <script type="math/tex">\{k_1,k_2,...,k_n\}</script>，对于第 <script type="math/tex">i</script> 个关键码有</p><ul><li>小顶堆：</li></ul><script type="math/tex; mode=display">\left\{    \begin{array}{l}        k_i \leq k_{2i} \\        k_i \leq k_{2i+1}    \end{array}\right.</script><ul><li>大顶堆：</li></ul><script type="math/tex; mode=display">\left\{    \begin{array}{l}        k_i \geq k_{2i} \\        k_i \geq k_{2i+1}    \end{array}\right.</script><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241012142227017.png" alt="image-20241012142227017" style="zoom:50%;"></p><p><strong>排序</strong>：需要进行两种基本操作 → 比较两个关键字的大小；将记录从一个位置移动到另一个位置</p><ul><li>内部排序：排序记录全部存放在内存中进行排序</li><li>外部排序：排序记录数量大，内存不能全部容纳，需对外存进行访问</li></ul><blockquote><p>对于 (3，2<sub>1</sub>，1，2<sub>2</sub>，5) → (1，2<sub>2</sub>，2<sub>1</sub>，3，5)，排序后 2 的相对次序变化了（第 2 个 2 到了第 1 个 2 的前面），则此类排序为不稳定的</p><p>归位：一趟排序就可确定某个元素的位置</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最坏时间复杂度</th><th style="text-align:center">最好时间复杂度</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">直接插入排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n)</script></td><td style="text-align:center"><script type="math/tex">O(1)</script></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><script type="math/tex">O(n^{1.3})</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n)</script></td><td style="text-align:center"><script type="math/tex">O(1)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">简单选择排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(1)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(1)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(n)</script></td><td style="text-align:center"><script type="math/tex">O(1)</script></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(n^2)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(log_2n)</script></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(nlog_2n)</script></td><td style="text-align:center"><script type="math/tex">O(n)</script></td><td style="text-align:center">稳定</td></tr></tbody></table></div><ul><li><p>直接插入排序：数组基本有序时，比较次数最少</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/插入排序.gif" alt="image-202410121535" style="zoom:50%;"></p></li><li><p>计数排序：适用于一组记录的关键字的取值均在 0 到 9 之间</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/计数排序.gif" alt="image-202410121536" style="zoom:50%;"></p></li><li><p>简单选择排序：<strong>归位</strong>，每次遍历找出剩余部分中的最小值并排到前面位置</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/简单选择排序.gif" alt="image-202410121532" style="zoom:50%;"></p></li><li><p>堆排序：<strong>归位</strong>，构建大/小顶堆，找出最大/小值排到后面位置，重复上述步骤</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/堆排序.gif" alt="image-202410121532" style="zoom:80%;"></p></li><li><p>冒泡排序：<strong>归位</strong></p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/冒泡排序.gif" alt="image-202410121538" style="zoom: 80%;"></p></li><li><p>快速排序：<strong>归位</strong>，分治算法</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/快速排序.gif" alt="image-202410121540" style="zoom: 80%;"></p></li><li><p>归并排序：分治法，元素基本有序时，比较次数最少</p><p><img src="/2024/12/05/12-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/归并排序.gif" alt="image-202410121545" style="zoom: 50%;"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-计算机网络</title>
      <link href="/2024/12/03/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/12/03/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="11-计算机网络-软件设计师"><a href="#11-计算机网络-软件设计师" class="headerlink" title="11. 计算机网络 - 软件设计师"></a>11. 计算机网络 - 软件设计师</h2><p><strong>网络设备</strong>：</p><ul><li>物理层的互连设备：中继器、集线器（多端口中继器）</li><li>数据链路层的互连设备：网桥、交换机（多端口网桥）</li><li>网络层互连设备：路由器</li><li>应用层互连设备：网关</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">能否隔离</th><th style="text-align:center">广播域</th><th style="text-align:center">冲突域</th></tr></thead><tbody><tr><td style="text-align:center">物理层</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table></div><blockquote><p>物理层的所有端口组成 1 个冲突域和 1 个广播域；数据链路层的 n 个端口形成 1 个广播域和 n 个冲突域</p></blockquote><p><strong>协议簇</strong>：</p><p><img src="/2024/12/03/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20241007103433760.png" alt="image-20241007103433760" style="zoom:50%;"></p><blockquote><p>所有带 T 的除了 TFTP 其他都是 TCP，所有不带 T 的除了 POP3 其他都是 UDP</p><p>协议和层次对应关系题，先排除带 ARP 的</p></blockquote><p>网际层协议：</p><ul><li>IP：不可靠的、无连接的</li></ul><p>传输层协议：</p><ul><li>TCP：可靠的、面向连接的、全双工的数据传输服务；三次握手协议<ul><li>可靠连接、连接管理、差错校验和重传、流量控制（可变大小的滑动窗口协议）、拥塞控制、端口寻址</li></ul></li><li>UDP：不可靠的、无连接的协议；提高传输的高速率性</li></ul><p><strong>电子邮件</strong>：</p><p>E-mail 系统基于客户端/服务器模式</p><p>E-mail 服务器主要采用 SMTP（简单邮件传输协议），传输 ASCII 码文本和文字性附件</p><p>MIME → 邮件附件扩展类型 POP3 → 接收邮件，每次传输以整个 E-mail 为单位，不能提供部分传输</p><p>PEM → 增强私密邮件保护协议 IMAP4 → 交互式数据访问协议</p><blockquote><p>简单邮件传送协议和用于接收邮件的 POP3 均是利用 TCP 端口，SMTP 所用端口号是 25，POP3 所用端口号是 110</p></blockquote><p><strong>ARP</strong>（地址解析协议）：</p><ul><li>网络层，将 IP 地址转换为物理地址（MAC 地址）</li><li>广播发送请求（ARP Request），单播传送响应（ARP Response）</li></ul><p><strong>RARP</strong>（反地址解析协议）：网络层，将物理地址（MAC 地址）转换为 IP 地址</p><p><strong>DHCP</strong>（动态主机配置协议）：</p><ul><li><p>功能：集中的管理、分配 IP 地址，使网络环境中的主机动态的获得 IP 地址、Gateway 地址、DNS 服务器地址等信息，并能够提升地址的使用率</p></li><li><p>DHCP 客户端可以从 DHCP 服务器获得本机 IP 地址、DNS 服务器地址、DHCP 服务器地址和默认网关的地址等</p></li><li><p>无效地址：Windows → 169.254.X.X Linux → 0.0.0.0</p><blockquote><p>169.254.X.X 是 Windows 系统在 DHCP 信息租用失败时自动给客户机分配的 IP 地址</p></blockquote></li></ul><p><strong>URL</strong>：协议名://主机名.域名.域名后缀.域名分类/目录/网页文件</p><div class="table-container"><table><thead><tr><th style="text-align:center">组织模式</th><th style="text-align:center">含义</th><th style="text-align:center">地理模式（顶级域名）</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">com</td><td style="text-align:center">商业组织</td><td style="text-align:center">cn</td><td style="text-align:center">中国</td></tr><tr><td style="text-align:center">edu</td><td style="text-align:center">教育机构</td><td style="text-align:center">hk</td><td style="text-align:center">中国香港</td></tr><tr><td style="text-align:center">gov</td><td style="text-align:center">政府机构</td><td style="text-align:center">mo</td><td style="text-align:center">中国澳门</td></tr><tr><td style="text-align:center">mil</td><td style="text-align:center">军事部门</td><td style="text-align:center">tw</td><td style="text-align:center">中国台湾</td></tr><tr><td style="text-align:center">net</td><td style="text-align:center">主要网络支持中心</td><td style="text-align:center">us</td><td style="text-align:center">美国</td></tr><tr><td style="text-align:center">org</td><td style="text-align:center">各类组织机构（非盈利团队）</td><td style="text-align:center">uk</td><td style="text-align:center">英国</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">国际组织</td><td style="text-align:center">jp</td><td style="text-align:center">日本</td></tr></tbody></table></div><p><strong>浏览器</strong>：</p><ul><li>本地主机，DNS 域名查询：本地 hosts 文件 → 本地 DNS 缓存 → 本地 DNS 服务器 → 根域名服务器</li><li>主域名服务器接收域名请求后：本地缓存 → 本地 hosts 文件 → 本地数据库 → 转发域名服务器</li></ul><p><strong>IP 地址和子网掩码</strong>：</p><p>IP 地址由 4 个小于 256 的数字组成。Internet 的 IP 地址共 32 位，4 个字节。</p><p>有两种表示格式：二进制格式和十进制格式</p><p>Internet 中的地址分为 5 类：A 类、B 类、C 类、D 类、E 类；全 0 代表网络，全 1 代表广播</p><ul><li>A 类：网络地址占 1 个字节（8 位），第一个字节的十进制值为 000~127</li><li>B 类：网络地址占 2 个字节，第一个字节的十进制值为 128~191</li><li>C 类：网络地址占 3 个字节，第一个字节的十进制值为 192~223</li></ul><p><img src="/2024/12/03/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20241008120931508.png" alt="image-20241008120931508" style="zoom: 50%;"></p><blockquote><p>前面几位标识是哪类地址</p><p>$可用主机地址=2^{主机地址位数}-2$（1 个全 0 地址和 1 个全 1 地址）</p><p>222.125.80.128/26 → $主机地址位=32-26=6，可用主机地址=2^6-2=62$</p><p>规定子网掩码为 255.255.192.0，则 A 类网络被划分为 1024 个子网</p><ul><li>A 类 →255.0.0.0→11111111 00000000 00000000 00000000</li><li>255.255.192.0→11111111 11111111 11000000 00000000</li><li>8 位+2 位=10 $2^{10}=1024$</li></ul><p>子网 172.6.32.0/20 被划分为子网 172.6.32.0/26 → 被划分为 $2^{26-20}=2^6=64$ 个子网</p></blockquote><p><strong>IPv6</strong>：128 位地址空间，$2^{128}$，是 IPv4 的$2^{96}$倍 <strong>IPv4</strong>：32 位地址空间，$2^{32}$</p><p>无线网络：蓝牙的覆盖范围最小，通信距离最短</p><p><strong>Windows 命令</strong>：</p><ul><li>ipconfig/release：DHCP 客户端手工释放 IP 地址</li><li>ipconfig/flushdns：清除本地 DNS 缓存内容</li><li>ipconfig/displaydns：显示本地 DNS 内容</li><li>ipconfig/registerdns：DNS 客户端手工向服务器进行注册</li><li>ipconfig：显示所有网络适配器的 IP 地址、子网掩码和缺省网关值</li><li>ipconfig/all：显示所有网络适配器的完整 TCP/IP 配置信息，包括 DHCP 服务是否已启动</li><li>ipconfig/renew：DHCP 客户端手工向服务器刷新请求（重新申请 IP 地址）</li><li>ping：检查网络是否连通，ping 127.0.0.1 → ping 本地 IP → ping 默认网关 → ping 远程主机</li></ul><p><strong>路由</strong>：</p><p>Windows 服务器收到一个 IP 数据包时，查找顺序：主机路由 → 网络路由（直连网络和远程网络）→ 默认路由</p><div class="table-container"><table><thead><tr><th style="text-align:center">路由类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">直连网络 ID（Directly attached network ID）</td><td style="text-align:center">用于直接连接的网络，Interface（或 next hop）可以为空</td></tr><tr><td style="text-align:center">远程网络 ID（Remote network ID）</td><td style="text-align:center">用于不直接连接的网络，可以通过其他路由器到达这种网络 Interface 字段是本地路由器的 IP</td></tr><tr><td style="text-align:center">主机路由（Host route）</td><td style="text-align:center">到达特定主机的路由，子网掩码为 255.255.255.255</td></tr><tr><td style="text-align:center">默认路由（Default route）</td><td style="text-align:center">无法找到确定路由时使用的路由，目标网络和网络掩码都是 0.0.0.0</td></tr><tr><td style="text-align:center">持久路由（Persistent route）</td><td style="text-align:center">利用 route add -p 命令添加的表项，每次初始化时，这种路由都会加入 Windows 的注册表中，同时加入路由表</td></tr></tbody></table></div><p>如果路由器收到了由多个路由协议转发的、关于某个目标的多条路由，则比较各个路由的管理距离，采用小的</p><p>路由来源 → 管理距离：直连路由 →0；静态路由 →1；EIGRP 汇总路由 →5；外部 BGP→20；内部 EIGRP→90；</p><p>IGRP→100；OSPF→110；IS-IS→115；RIP→120；EGP→140；ODR（按需路由）→160；外部 EIGRP→170；</p><p>内部 BGP→200；未知 →255</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-信息安全</title>
      <link href="/2024/12/03/10-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
      <url>/2024/12/03/10-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="10-信息安全-软件设计师"><a href="#10-信息安全-软件设计师" class="headerlink" title="10. 信息安全 - 软件设计师"></a>10. 信息安全 - 软件设计师</h2><p><strong>防火墙</strong>：通常分为内网、DMZ（公用服务器）、外网三个区域</p><ul><li><p>包过滤防火墙</p><ul><li>对用户完全透明，速度较快；不能防范黑客攻击</li><li>实行低水平控制，检查源地址、目的地址、协议、端口等</li></ul></li><li><p>应用代理网关防火墙</p><ul><li><p>彻底隔离内网与外网的直接通信，所有通信都必须经应用层代理软件转发</p></li><li><p>优点：检查应用层、传输层、网络层的协议特征，对数据包的检测能力比较强</p></li><li>缺点：难以配置，处理速度非常慢</li></ul></li><li><p>状态检测技术防火墙</p><ul><li>结合了代理防火墙的安全性和包过滤防火墙的高速度等优点，在不损失安全性的基础上，提高了代理防火墙的性能</li></ul></li></ul><p><strong>病毒</strong>：</p><p>计算机病毒的特征：传播性、隐蔽性、感染性、潜伏性、触发性、破坏性等</p><ul><li>蠕虫病毒（Worm）：欢乐时光、熊猫烧香、红色代码、爱虫病毒、震网</li><li>特洛伊木马（Trojan）：木马软件 → 冰河</li><li>后门病毒（Backdoor）</li><li>宏病毒（Macro）：感染对象主要是文本文档、电子表格等</li></ul><p><strong>网络攻击</strong>：</p><ul><li>拒绝服务攻击（Dos 攻击）：目的是使计算机或网络无法提供正常的服务，是不断向计算机发起请求来实现的</li><li>重放攻击：攻击者发送一个目的主机已经接受过的报文来达到攻击目的<br>攻击者利用网络监听或者其他方式盗取认证凭据，之后再重新发送给认证服务器<br>主要用于身份认证过程，目的是破坏认证的正确性</li><li>口令入侵攻击：使用某些合法用户的账号和口令登录到目的主机，然后再实施攻击活动</li><li>特洛伊木马：被伪装成程序或游戏，当用户下载了带有木马的软件或附件时，这个程序就会向黑客发起连接请求，建立连接后黑客就实施攻击活动</li><li>端口欺骗攻击：采用端口扫描找到系统漏洞从而实施攻击</li><li>网络监听：攻击者可以接收某一网段在同一条物理通道上传输的所有信息<br>使用网络监听可以轻松截取包括账号和口令在内的信息资料</li><li>IP 欺骗攻击：产生的 IP 数据包为伪造的源 IP 地址，以便冒充其他系统或发件人的身份</li><li>Sql 注入攻击：是黑客对数据库进行攻击的常用手段之一<br>没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患<br>攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，首先获取数据库的权限，就可获取用户账号和口令信息，以及对某些数据修改等</li><li>入侵检测技术：专家系统、模型检测、简单匹配</li></ul><p><strong>网络安全</strong>：</p><ul><li>SSL：传输层安全协议，端口号 443</li><li>TLS：传输层安全协议，建立在 SSL3.0 协议规范之上，是 SSL3.0 的后续版本</li><li>SSH：终端设备与远程站点之间建立安全连接的协议</li><li>HTTPS：以安全为目标的 HTTP 通道，即使用 SSL 加密算法的 HTTP</li><li>MIME：多用途互联网邮件扩展类型</li><li>PGP：优良保密协议，基于 RSA 公钥加密体系的邮件加密软件</li><li>IPSec：为 IP 数据报文进行加密</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-软件工程</title>
      <link href="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="9-软件工程-软件设计师"><a href="#9-软件工程-软件设计师" class="headerlink" title="9. 软件工程 - 软件设计师"></a>9. 软件工程 - 软件设计师</h2><p><strong>软件过程</strong>：</p><ul><li><p>能力成熟度模型（CMM）</p><ol><li><p>初始级（Initial）</p><p>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用</p></li><li><p>可重复级（Repeatable）</p><p>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功</p></li><li><p>已定义级（Defined）</p><p>管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件</p></li><li><p>已管理级（Managed）</p><p>制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制</p></li><li><p>优化级（Optimized）</p><p>加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进</p></li></ol></li><li><p>能力成熟度模型集成（CMMI）</p><ol><li>阶段式模型<ul><li>初始的：过程不可预测且缺乏控制</li><li>已管理的：过程为项目服务</li><li>已定义的：过程为组织服务</li><li>定量管理的：过程已度量和控制</li><li>优化的：集中于过程改进</li></ul></li><li>连续式模型<ul><li>CL~0~（未完成的）：过程域未执行或未得到 CL~1~中定义的所有目标</li><li>CL~1~（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标</li><li>CL~2~（已管理的）：其共性目标集中于已管理的过程的制度化</li><li>CL~3~（已定义级的）：其共性目标集中于已定义的过程的制度化</li><li>CL~4~（定量管理的）：其共性目标集中于可定量管理的过程的制度化</li><li>CL~5~（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效</li></ul></li></ol></li></ul><p><strong>软件过程模型</strong>：</p><ul><li><p>瀑布模型：需求明确/不发生变化，具备相关领域及类似规模系统的开发经验</p><ul><li>优点：容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试</li><li>V 模型：瀑布模型的一个变体</li></ul></li><li><p>增量模型：能够快速构造可运行产品，根据后续增量加入新功能，是瀑布模型的一个变体</p><ul><li>优点：具有瀑布模型的所有优点；第一个可交付版本所需成本和时间很少；开发由增量表示的小系统所承担的风险不大；运行增量投资</li></ul></li><li><p>演化模型：迭代的过程模型，尽快投入使用，逐步开发出完整的软件版本，适用于对软件需求缺乏准确认识的情况</p><ul><li>原型模型：用户需求不清、需求经常变化；系统规模不大、不复杂；能快速、低成本地构建原型</li><li>螺旋模型：适用于庞大、复杂并且具有高风险的系统；强调风险分析；结合了瀑布模型和演化模型</li></ul></li><li><p>喷泉模型：以用户需求为动力，以对象作为驱动的模型，适合面向对象的开发方法；支持软件重用和多项开发活动集成的局限性；开发过程具有迭代性和无间隙性 → 开发活动重复多次，不存在明显边界</p><ul><li>优点：提高软件项目的开发效率，节省开发时间</li><li>缺点：开发过程需要大量人员，不利于项目管理；要求严格管理文档，使得审核难度加大</li></ul></li><li><p>统一过程（UP）模型：用例和风险驱动，以架构为中心，迭代并且增量；每个迭代有 5 个核心工作流</p><ol><li>起始阶段：生命周期目标 — 专注于项目的初创活动</li><li>精化阶段：生命周期架构 — 进行需求分析和架构演进</li><li>构建阶段：初始运作功能 — 关注系统的构建，产生实现模型</li><li>移交阶段：产品发布 — 关注于软件提交方面的工作，产生软件增量</li></ol></li><li><p>敏捷方法：尽可能早地、持续地对有价值的软件的交付；每一种方法基于一套原则</p><ul><li><p>极限编程（XP）：轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式</p><ul><li>4 大价值观：沟通、简单性、反馈、勇气</li><li>5 个原则：快速反馈、简单性假设、逐步修改、提倡更改、优质工作</li><li>12 个最佳实践：计划游戏、小型发布、隐喻、简单设计、测试先行、重构、结对编程、集体代码所有制、持续集成、每周工作 40 个小时、现场客户、编码标准</li></ul></li><li><p>水晶法（Crystal）：每一个不同的项目都需要一套不同的策略、约定和方法论</p></li><li><p>并列争求法（Scrum）：每 30 天一次的迭代称为一个 “冲刺”，并按需求的优先级别来实现产品</p></li><li><p>自适应软件开发（ASD）：有 6 个基本原则</p></li><li><p>敏捷统一过程（AUP）：采用 “在大型上连续” “在小型上迭代” 原理构建系统，采用经典的 UP 阶段性活动</p><p>每个 AUP 迭代执行的活动：建模、实现、测试、部署、配置及项目管理、环境管理</p></li></ul></li></ul><p><strong>需求分析</strong>：</p><ul><li>软件需求：功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求、其他非功能性需求</li></ul><p><strong>系统设计</strong>：</p><ul><li>概要设计<ol><li>设计软件系统总体结构：把一个复杂的系统按功能划分成模块；确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口</li><li>数据结构及数据库设计<ul><li>数据结构的设计</li><li>数据库的设计：概念设计、逻辑设计、物理设计</li></ul></li><li>编写概要设计文档：概要设计说明书、数据库设计说明书、用户手册、修订测试计划</li><li>评审</li></ol></li><li>详细设计<ol><li>对每个模块进行详细的算法设计</li><li>对模块内的数据结构进行设计</li><li>对数据库进行物理设计</li><li>其他设计：代码设计、输入/输出格式设计、用户界面设计</li><li>编写详细设计说明书</li><li>评审</li></ol></li></ul><p><strong>系统测试</strong>：保证系统质量和可靠性的关键步骤，需要遵循以下基本原则：</p><ol><li>应尽早并不断地进行测试</li><li>测试工作应该避免由原开发软件的人或小组承担</li><li>在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果</li><li>在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件</li><li>在测试程序时，不仅要检验程序是否做了该做的事，还有检验程序是否做了不该做的事</li><li>严格按照测试计划来进行，避免测试的随意性</li><li>妥善保存测试计划、测试用例，作为软件文档的组成部分，为维护提供方便</li><li>测试用例都是精心设计出来的，可以为重新测试或追加测试提供方便</li><li><strong>系统测试阶段的测试目标来自于需求分析阶段</strong></li></ol><p><strong>测试策略</strong>：</p><ul><li>单元测试<ul><li>主要检查 模块缺口、局部数据结构、重要的执行路径、出错处理、边界条件</li><li>驱动模块（主程序）、桩模块（代替子模块，其内部可进行少量的数据处理）</li></ul></li><li>集成测试<ul><li>自顶向下集成测试：不用编写驱动模块，需要编写桩模块</li><li>自底向上集成测试：需要编写驱动模块，不用编写桩模块</li><li>回归测试：软件发生变更后，重新测试，防止变更所带来的错误</li><li>冒烟测试：时间关键项目的决定性机制</li></ul></li><li>确认测试</li><li>系统测试</li></ul><p><strong>测试方法</strong>：</p><ol><li><p>静态测试：被测程序不在机器上运行</p><ul><li>人工测试</li><li>计算机辅助静态分析</li></ul></li><li><p>动态测试：通过运行程序发现错误</p><ul><li><p>黑盒测试（功能测试）：不考虑软件的内部结构和特性</p><ul><li>等价类划分 → 有效等价类（符合规则）、无效等价类（不符合规则）</li><li>边界值分析 → 选取边界值进行测试</li><li>错误推测 → 基于经验和直觉推测程序中的错误</li><li>因果图</li></ul></li><li><p>McCabe 度量法</p><p>有向图 G 的环路复杂性的公式：$V(G)=m-n+2$</p><blockquote><p>其中 V(G)是有向图 G 的环路个数，m 是 G 中的有向弧数（箭头），n 是 G 中的节点数</p></blockquote></li><li><p>白盒测试（结构测试）：根据程序内部结构和逻辑设计测试用例</p><ol><li><p>逻辑覆盖（从弱到强）</p><ul><li><p>语句覆盖：选择足够的测试数据，使得程序中每条语句至少执行一次</p></li><li><p>判定覆盖（分支覆盖）：设计足够的测试用例，使得程序中每个判定表达式至少获得一次“真”和“假”值，或每一个取“真”分支和取“假”分支至少都通过一次</p></li><li><p>条件覆盖：构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次</p></li><li><p>判定/条件覆盖：设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次</p></li><li><p>条件组合覆盖：设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次</p><blockquote><p>满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖、判定/条件覆盖的</p></blockquote></li><li><p>路径覆盖：覆盖被测试程序中所有可能的路径</p></li></ul></li><li><p>循环覆盖：执行足够的测试用例，使得循环中的每个条件都得到验证</p></li><li><p>基本路径覆盖：在程序控制流图的基础上通过分析控制流图的环路复杂性，导出基本可执行路径集合</p></li></ol><blockquote><p>白盒测试原则：</p><ol><li>程序模块中的所有独立路径至少执行一次</li><li>在所有的逻辑判断中，取 “真” 和取 “假” 的两种情况至少都能执行一次</li><li>每个循环都应在边界条件和一般条件下各执行一次</li><li>测试程序内部数据结构的有效性等</li></ol></blockquote><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241004135812633.png" alt="image-20241004135812633" style="zoom:50%;"></p></li></ul></li></ol><p><strong>系统维护概述</strong>：</p><ul><li><p>系统可维护性的评价指标：可理解性、可测试性、可修改性</p></li><li><p>软件与维护文档：软件系统的文档可分为用户文档和系统文档</p><ul><li>文档是软件可维护性的决定因素，高质量文档对于软件产品的效益有着重要意义</li></ul></li><li><p>系统维护</p><ul><li>硬件维护</li><li>软件维护<ol><li>正确性维护：改正系统开发阶段已发生而测试阶段尚未发现的错误</li><li>适应性维护：使应用软件适应信息技术变化和管理需求变化而进行修改</li><li>完善性维护：为扩充功能和改善性能而进行的修改</li><li>预防性维护：为适应环境变化，主动增加预防性的新功能</li></ol></li><li>数据维护</li></ul></li><li><p>软件的质量属性：用 0~1 之间的数来度量</p><ul><li><p>可靠性：一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率</p><p>用$\frac{MTTF}{1+MTTF}$来度量，其中 MTTF 为平均无故障时间</p></li><li><p>可用性：在给定的时间点上，一个系统能够按照规格说明正确运作的概率</p><p>用$\frac{MTBF}{1+MTBF}$来度量，其中 MTBF 为平均失效间隔时间</p></li><li><p>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率</p><p>用$\frac{1}{1+MTTR}$来度量，其中 MTTR 为平均修复时间</p></li></ul></li></ul><p><strong>沟通路径</strong>（人数为 n 时）：</p><ul><li>无主程序员组：$沟通路径=\frac{(n-1)\times{n}}{2}$</li><li>主程序员组：$沟通路径=n-1$</li></ul><p><strong>软件项目估计</strong>：</p><ul><li>COCOMO 估算模型<ul><li>基本 COCOMO 模型：静态单变量模型</li><li>中级 COCOMO 模型：静态多变量模型</li><li>详细 COCOMO 模型：将软件系统模型分为系统、子系统、模块 3 个层次</li></ul></li><li>COCOMOII 模型<ul><li>应用组装模型 → 对象点</li><li>早期设计阶段模型 → 功能点</li><li>体系结构阶段模型 → 代码行</li></ul></li></ul><p><strong>进度管理</strong>：</p><ul><li><p>Gantt 图（甘特图）：能清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性；但不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，不能反映计划中有潜力的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title Gantt图实例</span><br><span class="line">section 任务1</span><br><span class="line">task1:a1,2008-01-01,180d</span><br><span class="line">section 任务2</span><br><span class="line">task2:a1,2008-02-01,270d</span><br><span class="line">section 任务3</span><br><span class="line">task3:a1,2008-07-01,150d</span><br></pre></td></tr></table></figure></li><li><p>项目计划评审技术（PERT）图：反映出任务之间的依赖关系，但不能反映任务之间的并行关系</p><ul><li>有向图，箭头表示任务（上面标记完成该任务所需时间），图中结点表示流入（指向）结点的任务结束，并开始流出（指向）结点的任务</li><li>只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始</li><li>最早时刻：在此时刻之前从该事件出发的任务不可能开始</li><li>最迟时刻：从事件出发的任务必须在此时刻之前开始</li><li>松弛时间：在不影响整个工期的前提下完成该任务有多少机动余地</li></ul><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241004210548242.png" alt="image-20241004210548242" style="zoom:50%;"></p><blockquote><p>做题技巧：关键路径选最长时间的路径，$任务N最多可以推迟开始的时间=工期时间-其最长时间路径耗费的时间$</p><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241004212129118.png" alt="image-20241004212129118" style="zoom:50%;"></p></blockquote></li><li><p>项目活动图：顶点表示项目里程碑，连接顶点的边表示活动，边上的值表示完成活动所需的时间</p><p>缩短关键路径上的活动才能缩短整个项目的工期</p><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241005094821448.png" alt="image-20241005094821448" style="zoom:50%;"></p><blockquote><p>关键路径为 A→C→F→G→I，即最长路径；关键路径长度为 4+3+3+7=17；里程碑 A、C、F、G、I 和活动 AC、CF、FG、GI 在关键路径上；活动 FH 的松弛时间是$最迟时刻-最早时刻$，即(17-4-3)-7=3</p></blockquote></li></ul><p><strong>软件配置管理</strong>：</p><ul><li>主要目标：变更标识、变更控制、版本控制、确保变更正确的实现、变更报告</li><li>主要内容<ul><li>版本 1：版本管理、配置支持、变更支持、过程支持、团队支持、变化报告、审计支持</li><li>版本 2：软件配置标识、变更管理、版本控制、系统建立、配置审核、配置状态报告</li></ul></li><li>配置数据库：开发库、受控库、产品库</li></ul><p><strong>风险管理</strong>：</p><ul><li>软件风险：不确定性和损失</li><li>项目风险：项目复杂度、规模及结构不确定性</li><li>技术风险：设计、实现、接口、验证、维护等方面的潜在问题</li><li>商业风险：市场风险、策略风险、销售风险、管理风险、预算风险</li></ul><p>风险识别：建立风险条目检查表</p><p>风险因素：性能、成本、支持、进度</p><p>风险预测（风险估计）：风险预测活动（风险发生的可能性）、评估风险影响（风险发生所产生的后果）</p><p>风险评估：一种对风险评估很有用的技术就是定义风险参照水准</p><p>风险控制：风险避免、风险监控、RMMM 计划（监控和管理计划）</p><p><strong>软件质量特性</strong>：</p><ul><li><p>ISO/IEC 9126 软件质量模型</p><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241005195158509.png" alt="image-20241005195158509" style="zoom:50%;"></p></li><li><p>McCall 软件质量模型：三层模型框架 → 质量特性、评价准则、度量指标</p><p><img src="/2024/12/03/9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20241005200348034.png" alt="image-20241005200348034" style="zoom: 33%;"></p></li></ul><p><strong>软件评审</strong>：</p><ul><li>设计质量<ol><li>评价软件的规格说明是否合乎用户的要求</li><li>评审可靠性，即是否能避免输入异常、硬件失效及软件失效所产生的失效</li><li>评审保密措施实现情况，即是否对系统使用资格进行检查</li><li>评审操作特性实施情况，即操作命令和操作信息的恰当性；输入数据与输入控制语句的恰当性；输出数据的恰当性；应答时间的恰当性等</li><li>评审性能实现情况，即是否达到所规定性能的目标值</li><li>评审软件是否具有可修改性、可扩充性、可互换性和可移植性</li><li>评审软件是否具有可测试性</li><li>评审软件是否具有复用性</li></ol></li><li>程序质量<ol><li>功能结构：数据结构、功能结构、数据结构与功能结构之间的对应关系</li><li>功能的通用性</li><li>模块的层次</li><li>模块结构：控制流结构、数据流结构、模块结构与功能结构之间的对应关系</li><li>处理过程的结构</li></ol></li><li>与运行环境的接口<ol><li>与硬件的接口</li><li>与用户的接口</li></ol></li><li>正式技术评审：揭露质量问题，发现软件中的错误</li></ul><p><strong>软件容错技术</strong>：</p><ul><li>结构冗余：静态冗余、动态冗余、混合冗余</li><li>信息冗余：为检测或纠正信息在运算或传输中的错误需外加一部分信息</li><li>时间冗余：以重复执行指令或程序来消除瞬时错误带来的影响</li><li>冗余附加技术<ul><li>在屏蔽硬件错误的容错技术中：<ul><li>关键程序和数据的冗余存储及调用；检测、表决、切换、重构、纠错和复算的实现</li></ul></li><li>在屏蔽软件错误的容错系统中：<ul><li>冗余备份程序的存储及调用；实现错误检测和错误恢复的程序；实现容错软件所需的固化程序</li></ul></li></ul></li></ul><p><strong>软件工具</strong>：</p><ul><li>软件开发工具：需求分析工具、设计工具、编码与排错工具、测试工具</li><li>软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-结构化开发</title>
      <link href="/2024/12/01/8-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2024/12/01/8-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="8-结构化开发-软件设计师"><a href="#8-结构化开发-软件设计师" class="headerlink" title="8. 结构化开发 - 软件设计师"></a>8. 结构化开发 - 软件设计师</h2><p><strong>系统设计的基本原理</strong>：</p><ol><li><p>抽象</p></li><li><p>模块化</p></li><li><p>信息隐蔽</p></li><li><p>模块独立</p><ul><li><p>衡量模块独立程度的标准：耦合性和内聚性</p></li><li><p>耦合：取决于各个模块之间接口的复杂程度、调用模块的方式以及通过接口的信息类型等。</p><p><img src="/2024/12/01/8-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/image-20241002102955819.png" alt="image-20241002102955819" style="zoom:50%;"></p><ul><li>无直接耦合：两个模块之间<strong>没有直接的关系</strong>，分别从属于不同模块的控制与调用，它们之间不传递任何信息</li><li>数据耦合：两个模块之间有调用关系，<strong>传递的是简单的数据值</strong></li><li>标记耦合：两个模块之间<strong>传递的是数据结构</strong></li><li>控制耦合：一个模块调用另一个模块时，<strong>传递的是控制变量</strong></li><li>外部耦合：模块间通过<strong>软件之外的环境</strong>联结</li><li>公共耦合：通过一个<strong>公共数据环境</strong>相互作用的那些模块间的耦合</li><li>内容耦合：当<strong>一个模块直接使用另一个模块的内部数据</strong>，或通过非正常入口转入另一个模块内部时</li></ul></li><li><p>内聚：一个内聚程度高的模块（在理想情况下）应当只做一件事</p><p><img src="/2024/12/01/8-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/image-20241002104154213.png" alt="image-20241002104154213" style="zoom:50%;"></p><ul><li>偶然内聚（巧合内聚）：一个模块内的各处理元素之间<strong>没有任何联系</strong></li><li>逻辑内聚：模块内<strong>执行若干个逻辑上相似的功能</strong>，通过参数确定该模块完成哪一个功能</li><li>时间内聚：把需要<strong>同时执行</strong>的动作组合在一起形成的模块称为时间内聚模块（特定时间）</li><li>过程内聚：一个模块完成多个任务，这些任务必须<strong>按指定的过程执行</strong></li><li>通信内聚：模块内的所有处理元素都在同一个<strong>数据结构</strong>上操作，或者各处理使用相同的输入数据或者产生相同的输出数据</li><li>顺序内聚：一个模块中的各个处理元素都密切相关于同一功能且必须<strong>顺序执行</strong>，前一个功能元素的输出就是下一个功能元素的输入</li><li>功能内聚：模块内的<strong>所有元素共同作用完成一个功能</strong>，缺一不可</li></ul></li></ul><blockquote><p>在将软件系统划分模块时，应尽量做到<strong>高内聚、低耦合</strong>，提高模块的独立性。</p></blockquote></li></ol><p><strong>系统结构设计原则</strong>：</p><ol><li>分解-协调原则 → 复杂问题分解成多个小问题，处理过程中根据系统总体要求协调各部门的关系</li><li>自顶向下原则 → 抓住系统总的功能目的，逐层分解，先确定上层模块的功能，再确定下层模块的功能</li><li>信息隐蔽、抽象的原则 → 上层模块只规定下层模块做什么和所属模块间的协调关系，但不规定怎么做</li><li>一致性原则 → 保证整个软件设计过程中具有统一的规范、统一的标准和统一的文件模式等</li><li>明确性原则 → 每个模块必须功能明确、接口明确，消除多重功能和无用接口</li><li>模块之间的耦合尽可能小，模块的内聚度尽可能高。</li><li>模块的扇入系数和扇出系数要合理。<br>一个模块直接调用其他模块的个数称为模块的扇出系数；一个模块被其他模块调用时，直接调用它的模块个数称为模块的扇入系数</li><li>模块的规模适当。</li><li>模块的作用范围应该在其控制范围之内。</li></ol><p><strong>系统文档</strong>：</p><ol><li>用户与系统分析人员在系统规划和系统分析阶段通过文档进行沟通<ul><li>文档：可行性研究报告、总体规划报告、系统开发合同和系统方案说明书等</li></ul></li><li>系统开发人员与项目管理人员通过文档在项目期内进行沟通<ul><li>文档：系统开发计划（包括工作任务分解表、PERT 图、甘特图和预算分配表等）、系统开发月报以及系统开发总结报告等项目管理文件</li></ul></li><li>系统测试人员与系统开发人员通过文档进行沟通<ul><li>系统测试人员可以根据系统方案说明书、系统开发合同、系统设计说明书和测试计划等文档对系统开发人员所开发的系统进行测试</li><li>系统测试人员再将评估结果撰写成系统测试报告</li></ul></li><li>系统开发人员与用户在系统运行期间进行沟通<ul><li>用户通过系统开发人员撰写的文档（用户手册和操作指南）运行系统</li></ul></li><li>系统开发人员与系统维护人员通过文档进行沟通<ul><li>文档：系统设计说明书和系统开发总结报告</li></ul></li><li>用户与维修人员在运行维护期间进行沟通<ul><li>用户在使用信息系统的过程中，将运行过程中的问题进行记载，形成系统运行报告和维护修改建议</li><li>系统维护人员根据维护修改建议以及系统开发人员留下的技术手册等文档对系统进行维护和升级</li></ul></li></ol><p><strong>数据流图</strong>：对系统的功能和功能之间的数据流进行建模</p><ul><li>顶层数据流图（父图）描述了系统的输入和输出</li></ul><p><strong>数据字典</strong>：为数据流图中（除外部实体外）的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明</p><ul><li><p>数据字典有 4 类条目：数据流、数据项（组成数据流和数据存储的最小元素）、数据存储、基本加工</p></li><li><p>对加工的描述称为 “小说明” 或 “加工逻辑说明”，常用的加工逻辑描述方法有以下 3 种：</p><ul><li><p>结构化语言：一种介于自然语言和形式化语言之间的半形式化语言，是自然语言的一个受限子集</p><p>结构分为内层和外层</p><p>外层：用来描述控制结构，采用 顺序结构、选择结构、重复结构 3 种基本结构</p></li><li><p>判定表（决策表）：能够清楚地表示复杂的条件组合与应做的动作之间的对应关系</p></li><li><p>判定树：判定表的变形，更易于理解和使用</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 结构化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-操作系统</title>
      <link href="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="7-操作系统-软件设计师"><a href="#7-操作系统-软件设计师" class="headerlink" title="7. 操作系统 - 软件设计师"></a>7. 操作系统 - 软件设计师</h2><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240927220129225.png" alt="image-20240927220129225" style="zoom:50%;"></p><blockquote><p>编辑程序、汇编程序、编译程序、数据库管理系统等系统软件和应用软件都是建立在操作系统基础上的</p></blockquote><p><strong>进程管理</strong>（处理机管理）：</p><p>前趋图是一个有向无循环图，由结点和有向边构成，结点代表各程序段的操作，而结点间的有向边表示两个程序段操作之间存在的前趋关系。（输入是计算的前趋，计算是输入的后继）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((输入))--&gt;B((计算))</span><br><span class="line">B((计算))--&gt;C((输出))</span><br></pre></td></tr></table></figure><p>程序顺序执行的特征：顺序性、封闭性、可再现性</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240928102337387.png" alt="image-20240928102337387" style="zoom:50%;"></p><blockquote><p>如何确定 S~n~对应哪条有向边：</p><p>P~1~P~2~ → 12 P~1~P~3~ → 13 P~2~P~3~ → 23 P~3~P~4~ → 34</p><p>根据 12 &gt; 13 &gt; 23 &gt; 34，可得 P~1~P~2~ → S1 P~1~P~3~ → S2 P~2~P~3~ → S3 P~3~P~4~ → S4</p></blockquote><p>程序并发执行的特征：</p><ol><li>失去了程序的封闭性</li><li>程序和机器的执行程序的活动不再一一对应</li><li>并发程序间的相互制约性</li></ol><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240928114438200.png" alt="image-20240928114438200" style="zoom:50%;"></p><blockquote><p>图 4-2 中，I~2~与 C~1~并行执行；I~3~、C~2~与 P~1~并行执行；C~3~与 P~2~并行执行。其中，I~2~、I~3~受到 I~1~ 的间接制约，C~2~、C~3~受到 C~1~的间接制约，P~2~、P~3~受到 P~1~ 的间接制约，而 C~1~、P~1~受到 I~1~ 的直接制约，等等。</p></blockquote><p><strong>进程</strong>是资源分配和独立运行的基本单位</p><p>进程的 3 种基本状态：运行、就绪、阻塞</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240928121033575.png" alt="image-20240928121033575" style="zoom:50%;"></p><blockquote><p>例题：<img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240928132129698.png" alt="image-20240928132129698" style="zoom:50%;"></p></blockquote><p><strong>进程通信</strong>：指各个进程交换信息的过程</p><p>同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。</p><p>临界区（进程中对临界资源实施操作的程序段）管理的原则：</p><ol><li>有空即进</li><li>无空则等</li><li>有限等待</li><li>让权等待</li></ol><p><strong>信号量</strong>是一个整型变量，根据控制对象的不同被赋予不同的值，分类如下：</p><ol><li>公用信号量。实现进程间的互斥，初值为 1 或资源的数目</li><li>私用信号量。实现进程间的同步，初值为 0 或某个正整数</li></ol><blockquote><p>信号量 S 的物理意义：$S\geq{0}$ 时表示资源的可用数，$S&lt;0$ 时其绝对值表示阻塞队列中等待该资源的进程数</p></blockquote><p><strong>PV 操作</strong>是实现进程同步与互斥的常用方法，是低级通信原语，在执行期间不可分割。</p><ul><li><p>P 操作定义：S:=S-1，若$S\geq{0}$，则执行 P 操作的进程继续执行；若$S&lt;0$，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列</p></li><li><p>V 操作定义：S:=S+1，若$S&gt;0$，则执行 V 操作的进程继续执行；若$S\leq{0}$，则从阻塞队列中唤醒一个进程，并将其插入就绪队列，然后执行 V 操作的进程继续</p></li></ul><blockquote><p>互斥情况下，P、V 成对出现</p></blockquote><ul><li><p>利用 PV 操作实现进程的互斥：令信号量 mutex 的初值为 1，当进入临界区时执行 P 操作，退出临界区时执行 V 操作。</p></li><li><p>利用 PV 操作实现进程的同步：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240929130539153.png" alt="image-20240929130539153"></p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240929133637324.png" alt="image-20240929133637324"></p></li></ul><blockquote><p>例题：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930090149267.png" alt="image-20240930090149267"></p></blockquote><p><strong>死锁</strong>：</p><p>当有 n 个进程、m 个资源、且每个进程所需要的资源数为 k，并且系统采用的分配策略是轮流地为每个进程分配资源时，判断是否会发生死锁的公式如下：</p><script type="math/tex; mode=display">m\geq{n(k-1)+1}</script><blockquote><p>结果为真就不会发生死锁，为假就会发生死锁</p><p>解释：此时每个进程都分配了$(k-1)$个资源，只需要再分配 1 个资源让其中一个进程运行完成，即不会发生死锁</p></blockquote><p><strong>进程资源图</strong>：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930095349855.png" alt="image-20240930095349855"></p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930100921801.png" alt="image-20240930100921801" style="zoom:50%;"></p><p><strong>死锁避免：</strong></p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930141050952.png" alt="image-20240930141050952" style="zoom:50%;"></p><blockquote><p>解题思路：</p><p>（1）$R_n剩余可用资源数=R_n的可用资源数 - R_n已分配资源数$</p><p>（2）此时剩余可用资源数：$R_1→2，R_2→0，R_3→1$ ，只能满足 P5 仍需的资源数：$R_1→1，R_2→0，R_3→1$<br>故排除 A 和 C；<br>P5 运行完毕后返回系统资源，剩余可用资源数变为：$R_1→3，R_2→1，R_3→1$，只能满足 P2 仍需的资源数： $R_1→2，R_2→1，R_3→0$，故排除 D（剩余顺序推导过程同上）</p></blockquote><p><strong>线程</strong>：可独立调度和分配的基本单位</p><blockquote><p>同属一个进程的线程<strong>共享进程</strong>所拥有的全部<strong>资源</strong>（线程间是不可见的，不能共享线程间的资源）</p></blockquote><p><strong>局部性原理</strong>：</p><ul><li>时间局限性：程序中存在着大量的循环操作</li><li>空间局限性：程序在一段时间内所访问的地址可能集中在一定的范围内，原因：程序是顺序执行的</li></ul><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930145132432.png" alt="image-20240930145132432" style="zoom:50%;"></p><blockquote><p>页号 1 和 3 不在内存中，故排除 1 和 3；在剩下的页号中按 “状态位 → 访问位 → 修改位” 顺序向下找，淘汰值为 1 的页号</p></blockquote><p><strong>分页存储管理</strong>：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240930151214588.png" alt="image-20240930151214588" style="zoom:50%;"></p><p><strong>段页式存储管理</strong>：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001102148146.png" alt="image-20241001102148146" style="zoom:50%;"></p><p><strong>缓冲区</strong>：缓冲区为空时才可输入，为满时才可输出</p><ul><li><p>单缓冲区：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001111825996.png" alt="image-20241001111825996" style="zoom:50%;"></p></li><li><p>双缓冲区：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001112904381.png" alt="image-20241001112904381" style="zoom:50%;"></p></li></ul><p><strong>硬盘调度算法</strong>：（设磁头位于 53，请求顺序为 98、183、37、122、14、124、65、67）</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001124156584.png" alt="image-20241001124156584" style="zoom:50%;"></p><ol><li><p>先来先服务（FCFS）</p><p>按照请求顺序移动：53→98→183→37→122→14→124→65→67</p></li><li><p>最短寻道时间优先（SSTF）</p><p>优先请求距离当前最近的：53→65→67→37→14→98→122→124→183</p></li><li><p>扫描算法（SCAN）或 电梯调度算法</p><p>从磁头沿指定方向一直移动到尽头，再反向移动：53→37→14→65→67→98→122→124→183</p></li><li><p>循环扫描算法（CSCAN）或 单向扫描算法</p><p>从磁头沿指定方向一直移动到尽头，再返回到另一个尽头，继续移动构成循环：<br>53→65→67→98→122→124→183→14→37</p></li></ol><blockquote><p>从 n → m，$磁头移动=|n-m|$</p></blockquote><p><strong>旋转调度算法</strong>：</p><ul><li><p>文件在磁盘上连续存放：</p><p>$第1个记录耗费时间=读写时间+处理时间$</p><p>$第2\sim{n}个记录耗费时间=(读写头到下一个记录位置的时间+读写时间+处理时间)\times(记录总数-1)$</p></li><li><p>非连续存放：</p><p>$每块读取时间=移动一个磁道所需时间\times{相邻数据块的平均距离}+每块旋转延迟时间+传输时间$</p></li></ul><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001133519054.png" alt="image-20241001133519054" style="zoom:50%;"></p><p><strong>链式存储结构</strong>：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001144210524.png" alt="image-20241001144210524" style="zoom:50%;"></p><p><strong>多级索引结构</strong>：</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001141806285.png" alt="image-20241001141806285" style="zoom:50%;"></p><p><strong>文件目录</strong>：损坏会对系统造成较大的影响</p><ul><li>文件控制块，包含三类信息：基本信息类、存取控制信息类、使用信息类</li><li>目录结构：一级目录结构、二级目录结构、多级目录结构<ul><li>全文件名：D:\Program\C-prog\f1.c</li><li>绝对路径：D:\Program\C-prog\（不用加上文件名）</li><li>相对路径：Program\C-prog\ 或 .\C-prog\ 或 C-prog\（当前位于 Program 目录时）</li></ul></li></ul><p><strong>位示图</strong>：用二进制的一位来表示一个物理块的使用情况；0→ 空闲，1→ 占用</p><p><img src="/2024/12/01/7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20241001153104700.png" alt="image-20241001153104700" style="zoom:50%;"></p><p><strong>文件权限</strong>：</p><p>文件权限可以用三位八进制数字表示，每一位数字代表所有者（user）、组（group）和其他用户（others）的权限。每个权限位可以是以下组合之一：</p><ul><li>读取 (r) → 4</li><li>写入 (w) → 2</li><li>执行 (x) → 1</li></ul><blockquote><p>例题：某个程序所有者拥有所有权限，组成员有读取和运行的权限，其他用户只有运行的权限，该程序的权限为___。</p><ul><li><strong>所有者</strong>：拥有所有权限 $= 4+2+1 = 7$</li><li><strong>组成员</strong>：拥有读取和执行权限 $= 4+1 = 5$</li><li><strong>其他用户</strong>：只有执行权限 $= 1$</li></ul><p>故该程序的权限为<strong>751</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-设计模式</title>
      <link href="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="6-设计模式-软件设计师"><a href="#6-设计模式-软件设计师" class="headerlink" title="6. 设计模式 - 软件设计师"></a>6. 设计模式 - 软件设计师</h2><p>目的：</p><ul><li>创建型模式：与对象的创建有关</li><li>结构型模式：处理类或对象的组合</li><li>行为型模式：对类或对象怎样交互和怎样分配职责进行描述</li></ul><p>分类：</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240924151259308.png" alt="image-20240924151259308" style="zoom:50%;"></p><p>简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类</p><p>在简单工厂模式中用于被创建实例的方法通常为静态方法（static），因此又称为静态工厂方法</p><ul><li>工厂（核心）：负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象</li><li>封装产品：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象</li><li>具体产品：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例，它要实现抽象产品中声明的抽象方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Product &lt;|-- ProductA</span><br><span class="line">Product &lt;|-- ProductB</span><br><span class="line">ProductA &lt;-- Factory</span><br><span class="line">ProductB &lt;-- Factory</span><br><span class="line">note for Product &quot;&lt;&lt; abstract &gt;&gt;&quot;</span><br><span class="line">Product: +info()</span><br><span class="line">class ProductA &#123;</span><br><span class="line">+info(): void</span><br><span class="line">&#125;</span><br><span class="line">class ProductB &#123;</span><br><span class="line">+info(): void</span><br><span class="line">&#125;</span><br><span class="line">class Factory &#123;</span><br><span class="line">+createProduct(): Product</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="Factory-Method（工厂方法）"><a href="#Factory-Method（工厂方法）" class="headerlink" title="Factory Method（工厂方法）"></a>Factory Method（工厂方法）</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921093040850.png" alt="image-20240921093040850" style="zoom:50%;"></p><p>适用性：</p><ul><li>当一个类不知道它所必须创建的对象的类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</li></ul><h4 id="Abstract-Factory（抽象工厂）"><a href="#Abstract-Factory（抽象工厂）" class="headerlink" title="Abstract Factory（抽象工厂）"></a>Abstract Factory（抽象工厂）</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921095137783.png" alt="image-20240921095137783" style="zoom:50%;"></p><p>适用性：</p><ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当提供一个产品类库，只想显示它们的接口而不是实现时</li></ul><h4 id="Builder（生成器）"><a href="#Builder（生成器）" class="headerlink" title="Builder（生成器）"></a>Builder（生成器）</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921104821651.png" alt="image-20240921104821651" style="zoom:50%;"></p><p>适用性：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ul><h4 id="Prototype（原型）"><a href="#Prototype（原型）" class="headerlink" title="Prototype（原型）"></a>Prototype（原型）</h4><p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921111906840.png" alt="image-20240921111906840" style="zoom:50%;"></p><p>适用性：</p><ul><li>当一个系统应该独立于它的产品创建、构成和表示时</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载</li><li>为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些</li></ul><h4 id="Singleton（单例）"><a href="#Singleton（单例）" class="headerlink" title="Singleton（单例）"></a>Singleton（单例）</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921114054075.png" alt="image-20240921114054075" style="zoom:50%;"></p><p>适用性：</p><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h4 id="Adapter（适配器）"><a href="#Adapter（适配器）" class="headerlink" title="Adapter（适配器）"></a>Adapter（适配器）</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921135414313.png" alt="image-20240921135414313" style="zoom:50%;"></p><p>适用性：</p><ul><li>想使用一个已经存在的类，而它的接口不符合要求</li><li>想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作</li><li>（仅适用于对象 Adapter）想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口</li></ul><h4 id="Bridge（桥接）"><a href="#Bridge（桥接）" class="headerlink" title="Bridge（桥接）"></a>Bridge（桥接）</h4><p>将抽象部分与其实现部分分离，使它们都可以独立地变化。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921143356621.png" alt="image-20240921143356621" style="zoom:50%;"></p><p>适用性：</p><ul><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译</li><li>（C++）想对客户完全隐藏抽象的实现部分</li><li>有许多类要生成的类层次结构</li><li>想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点</li></ul><h4 id="Composite（组合）"><a href="#Composite（组合）" class="headerlink" title="Composite（组合）"></a>Composite（组合）</h4><p>将对象组合成树型结构以表示 “部分-整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921151818213.png" alt="image-20240921151818213" style="zoom:50%;"></p><p>适用性：</p><ul><li>想表示对象的部分-整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象</li></ul><h4 id="Decorator（装饰器）"><a href="#Decorator（装饰器）" class="headerlink" title="Decorator（装饰器）"></a>Decorator（装饰器）</h4><p>动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240921205726136.png" alt="image-20240921205726136" style="zoom:50%;"></p><p>适用性：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li><li>处理那些可以撤销的职责</li><li>当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类</li></ul><h4 id="Facade（外观）"><a href="#Facade（外观）" class="headerlink" title="Facade（外观）"></a>Facade（外观）</h4><p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922131746652.png" alt="image-20240922131746652" style="zoom:50%;"></p><p>适用性：</p><ul><li>要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制,但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade 层</li><li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性</li><li>当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系</li></ul><h4 id="Flyweight（享元）"><a href="#Flyweight（享元）" class="headerlink" title="Flyweight（享元）"></a>Flyweight（享元）</h4><p>运用共享技术有效地支持大量细粒度的对象。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922133837842.png" alt="image-20240922133837842" style="zoom:50%;"></p><p>适用性：</p><ul><li>一个应用程序使用了大量的对象</li><li>完全由于使用大量的对象，造成很大的存储开销</li><li>对象的大多数状态都可变为外部状态</li><li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li><li>应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值</li></ul><h4 id="Proxy（代理）"><a href="#Proxy（代理）" class="headerlink" title="Proxy（代理）"></a>Proxy（代理）</h4><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922140920876.png" alt="image-20240922140920876" style="zoom:50%;"></p><p>适用性：</p><ul><li>远程代理（Remote Proxy）为一个对象在不同地址空间提供局部代表</li><li>虚代理（Virtual Proxy）根据需要创建开销很大的对象</li><li>保护代理（Protection Proxy）控制对原始对象的访问，用于对象应该有不同的访问权限的时候</li><li>智能引用（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；当第一次引用一个持久对象时，将它装入内存;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><h4 id="Chain-of-Responsibility（责任链）"><a href="#Chain-of-Responsibility（责任链）" class="headerlink" title="Chain of Responsibility（责任链）"></a>Chain of Responsibility（责任链）</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922142546275.png" alt="image-20240922142546275" style="zoom:50%;"></p><p>适用性：</p><ul><li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定</li><li>想在不明确指定接收者的情况下向多个对象中的一个提交一个请求</li><li>可处理一个请求的对象集合应被动态指定</li></ul><h4 id="Command（命令）"><a href="#Command（命令）" class="headerlink" title="Command（命令）"></a>Command（命令）</h4><p>将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922144024514.png" alt="image-20240922144024514" style="zoom:50%;"></p><p>适用性：</p><ul><li>抽象出待执行的动作以参数化某对象。Command 模式是过程语言中的回调（Callback）机制的一个面向对象的替代品</li><li>在不同的时刻指定、排列和执行请求。一个 Command 对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传递给另一个不同的进程并在那儿实现该请求</li><li>支持取消操作。Command 的 Execute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个 Unexecute 操作，该操作取消上一次 Execute 调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用 Unexecute 和 Execute 来实现重数不限的“取消“和“重做”</li><li>支持修改日志。这样当系统崩溃时，这些修改可以被重做一遍。在 Command 接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用 Execute 操作重新执行它们</li><li>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。Command 模式提供了对事务进行建模的方法。Command 有一个公共接口，使得可以用同一种方式调用所有的事务，同时使用该模式也易于添加新事务以扩展系统</li></ul><h4 id="Interpreter（解释器）"><a href="#Interpreter（解释器）" class="headerlink" title="Interpreter（解释器）"></a>Interpreter（解释器）</h4><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240922152019189.png" alt="image-20240922152019189" style="zoom:50%;"></p><p>适用性：</p><ul><li>该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无须构建抽象语法树即可解释表达式，这样可以节省空间还可能节省时间</li><li>效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。不过，即使在这种情况下，转换器仍然可用该模式实现</li></ul><h4 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h4><p>提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240923135915596.png" alt="image-20240923135915596" style="zoom:50%;"></p><p>适用性：</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul><h4 id="Mediator（中介者）"><a href="#Mediator（中介者）" class="headerlink" title="Mediator（中介者）"></a>Mediator（中介者）</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240923142412076.png" alt="image-20240923142412076" style="zoom:50%;"></p><p>适用性：</p><ul><li>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解</li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul><h4 id="Memento（备忘录）"><a href="#Memento（备忘录）" class="headerlink" title="Memento（备忘录）"></a>Memento（备忘录）</h4><p>在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240923145716344.png" alt="image-20240923145716344" style="zoom:50%;"></p><p>适用性：</p><ul><li>必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态</li><li>如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性</li></ul><h4 id="Observer（观察者）"><a href="#Observer（观察者）" class="headerlink" title="Observer（观察者）"></a>Observer（观察者）</h4><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240923151810179.png" alt="image-20240923151810179" style="zoom:50%;"></p><p>适用性：</p><ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用</li><li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时</li><li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的</li></ul><h4 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a>State（状态）</h4><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240923222136524.png" alt="image-20240923222136524" style="zoom:50%;"></p><p>适用性：</p><ul><li>一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State 模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化</li></ul><h4 id="Strategy（策略）"><a href="#Strategy（策略）" class="headerlink" title="Strategy（策略）"></a>Strategy（策略）</h4><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240924110000913.png" alt="image-20240924110000913" style="zoom:50%;"></p><p>适用性：</p><ul><li>许多相关的类仅仅是行为有异。“策略” 提供了一种用多个行为中的一个行为来配置一个类的方法</li><li>需要使用一个算法的不同变体。例如，定义一些反映不同空间的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句</li></ul><h4 id="Template-Method（模板方法）"><a href="#Template-Method（模板方法）" class="headerlink" title="Template Method（模板方法）"></a>Template Method（模板方法）</h4><p>定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240924112530994.png" alt="image-20240924112530994" style="zoom:50%;"></p><p>适用性：</p><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复</li><li>控制子类扩展。模板方法旨在特定点调用 “hook” 操作（默认的行为，子类可以在必要时进行重定义扩展），这就只允许在这些点进行扩展</li></ul><h4 id="Visitor（访问者）"><a href="#Visitor（访问者）" class="headerlink" title="Visitor（访问者）"></a>Visitor（访问者）</h4><p>表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p><img src="/2024/12/01/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240924133930755.png" alt="image-20240924133930755" style="zoom:50%;"></p><p>适用性：</p><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作 “污染” 这些对象的类。Visitor 使得用户可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-UML</title>
      <link href="/2024/11/29/5-UML/"/>
      <url>/2024/11/29/5-UML/</url>
      
        <content type="html"><![CDATA[<h2 id="5-UML-软件设计师"><a href="#5-UML-软件设计师" class="headerlink" title="5. UML - 软件设计师"></a>5. UML - 软件设计师</h2><p><strong>事物</strong>：对模型中最具有代表性的成分的抽象</p><ul><li><p>结构事物</p><p><img src="/2024/11/29/5-UML/image-20240914153935929.png" alt="image-20240914153935929" style="zoom:50%;"></p></li><li><p>行为事物</p><ul><li><p>交互</p></li><li><p>状态机</p></li><li><p>活动</p><p><img src="/2024/11/29/5-UML/image-20240914154401335.png" alt="image-20240914154401335" style="zoom:50%;"></p></li></ul></li><li><p>分组事物</p><ul><li>是 UML 模型的组织部分</li><li>最主要的分组事物是包</li></ul></li><li><p>注释事物</p><ul><li><p>是 UML 模型的解释部分</p></li><li><p>注解是一种主要的注释事物</p><p><img src="/2024/11/29/5-UML/image-20240914154631898.png" alt="image-20240914154631898" style="zoom:50%;"></p></li></ul></li></ul><p><strong>关系</strong>：把事物结合在一起</p><ul><li><p>依赖：一个事物（独立事物）发生变化会影响另一个事物（依赖事物）</p><p><img src="/2024/11/29/5-UML/image-20240914155219816.png" alt="image-20240914155219816" style="zoom:50%;"></p></li><li><p>关联：一种结构关系，描述了一组链，链是对象之间的连接</p><p>关联上可以标注重复度（多重度）和角色</p><ul><li><p>多重度：一个类的实例能够与另一个类的多少个实例相关联</p></li><li><p>聚合：部分和整体的生命周期不一致，整体消失，部分仍然存在，部分可以脱离整体存在</p></li><li>组合：部分和整体的生命周期一致，整体消失，部分也存在，部分不可以脱离整体而存在</li></ul><p><img src="/2024/11/29/5-UML/image-20240914161607698.png" alt="image-20240914161607698"></p><blockquote><p>图中交叉关联：1 个雇主对应 0 个或多个员工，1 个员工对应 0 个或 1 个雇主</p></blockquote></li><li><p>泛化：一种特殊/一般关系，特殊元素（子元素）的对象可替代一般元素（父元素）的对象；子元素共享了父元素的结构和行为</p><p><img src="/2024/11/29/5-UML/image-20240914162247013.png" alt="image-20240914162247013" style="zoom:50%;"></p></li><li><p>实现：一个类元指定了由另一个类元保证执行的契约</p><p>使用实现关系的情况：</p><ul><li>在接口和实现它们的类或构件之间</li><li>在用例和实现它们的协作之间</li></ul><p><img src="/2024/11/29/5-UML/image-20240914162548340.png" alt="image-20240914162548340" style="zoom:50%;"></p></li></ul><p><strong>图</strong>：聚集了相关的事物</p><ul><li><p>类图</p><ul><li>包括内容：类，接口，协作，依赖、泛化和关联关系</li></ul><p><img src="/2024/11/29/5-UML/image-20240915104912834.png" alt="image-20240915104912834" style="zoom: 50%;"></p><ul><li>使用类图的方式：<ol><li>对系统的词汇建模</li><li>对简单的协作建模</li><li>对逻辑数据库模式建模</li></ol></li></ul></li><li><p>对象图：某一时刻一组对象以及它们之间的关系</p><p><img src="/2024/11/29/5-UML/image-20240915112930753.png" alt="image-20240915112930753" style="zoom:50%;"></p></li><li><p>用例图：一组用例、参与者以及它们之间的关系</p><ul><li><p>包括内容：</p><ol><li>用例</li><li>参与者</li><li>用例之间的 <strong>扩展关系&lt;\<extend>&gt;</extend></strong> 和 <strong>包含关系&lt;\<include>&gt;</include></strong> ，参与者和用例之间的<strong>关联</strong>关系，用例与用例以及参与者与参与者之间的<strong>泛化</strong>关系</li></ol><p><img src="/2024/11/29/5-UML/image-20240915145838224.png" alt="image-20240915145838224" style="zoom:50%;"></p></li><li><p>包含关系：</p><p><img src="/2024/11/29/5-UML/image-20240915145734412.png" alt="image-20240915145734412"></p></li><li><p>扩展关系：</p><p><img src="/2024/11/29/5-UML/image-20240915151419242.png" alt="image-20240915151419242"></p></li><li><p>泛化关系：</p><p><img src="/2024/11/29/5-UML/image-20240915153145016.png" alt="image-20240915153145016" style="zoom:50%;"></p></li></ul></li><li><p>交互图：用于对系统的动态方面进行建模</p><ul><li><p>包括内容：对象、链和消息</p></li><li><p>序列图（顺序图）：强调消息时间顺序</p><p><img src="/2024/11/29/5-UML/image-20240915202836204.png" alt="image-20240915202836204" style="zoom:50%;"></p><blockquote><p>序列图不同于通信图的特征：</p><ol><li>序列图有对象生命线（垂直虚线），表示一个对象在一段时间内存在</li><li>序列图有控制焦点（瘦高矩形），表示一个对象执行一个动作所经历的时间段，可以是直接执行或通过下级过程执行；矩形顶部表示动作开始，底部表示动作结束</li></ol></blockquote></li><li><p>通信图（协作图）：强调接收和发送消息的对象的结构组织，展现了对象之间的消息流及其顺序</p><p><img src="/2024/11/29/5-UML/image-20240915210154211.png" alt="image-20240915210154211" style="zoom:50%;"></p><blockquote><p>特性：</p><ol><li>通信图有路径</li><li>通信图有顺序号</li></ol></blockquote></li></ul></li><li><p>状态图：强调对象行为的事件顺序（反应型对象建模），关注系统的动态视图</p><ul><li><p>状态：规定了系统对事件的响应方式</p><p><img src="/2024/11/29/5-UML/image-20240916123950457.png" alt="image-20240916123950457" style="zoom:50%;"></p></li><li><p>活动</p><p>活动表的语法格式：$事件名(参数表)/动作表达式$</p><p><img src="/2024/11/29/5-UML/image-20240916131202139.png" alt="image-20240916131202139"></p></li><li><p>事件</p><p>事件表达式的语法：$事件说明[监护条件]/动作表达式$</p><p>事件说明的语法：$事件名(参数表)$</p></li><li><p>转换（迁移）：由事件触发</p><p><img src="/2024/11/29/5-UML/image-20240916133606335.png" alt="image-20240916133606335" style="zoom:50%;"></p></li></ul></li><li><p>活动图：强调对象间的控制流程，专注于系统的动态视图</p><p><img src="/2024/11/29/5-UML/image-20240916143313485.png" alt="image-20240916143313485" style="zoom:50%;"></p><ul><li>一般包括：活动状态和动作状态、转换和对象</li><li>可以表示：分支、合并、分岔和汇合</li><li>使用活动图的方式：<ol><li>对工作流建模</li><li>对操作建模</li></ol></li></ul></li><li><p>构件图（组件图）：展现了一组构件（组件）之间的组织和依赖，专注于系统的静态实现视图</p><p><img src="/2024/11/29/5-UML/image-20240916144616299.png" alt="image-20240916144616299" style="zoom:50%;"></p></li><li><p>部署图：对面向对象系统的物理方面建模的方法，对系统的静态部署视图进行建模</p><p>展现了系统的软件和硬件之间的关系，在实施阶段使用</p><p><img src="/2024/11/29/5-UML/image-20240916150054021.png" alt="image-20240916150054021" style="zoom:50%;"></p><p>UML 图总和：</p></li></ul><script type="math/tex; mode=display">\left\{\begin{array}{ll}静态建模:类图、对象图、用例图 \\动态建模:序列图(顺序图，时序图)、通信图(协作图)、状态图、活动图 \\物理建模:构件图(组件图)、部署图 \\交互图:序列图(顺序图，时序图)、通信图(协作图)\end{array}\right.</script>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-面向对象</title>
      <link href="/2024/11/28/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/11/28/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="4-面向对象-软件设计师"><a href="#4-面向对象-软件设计师" class="headerlink" title="4. 面向对象 - 软件设计师"></a>4. 面向对象 - 软件设计师</h2><p><strong>类</strong>：</p><ul><li>实体类</li><li>接口类（边界类）</li><li>控制类</li></ul><p><strong>对象</strong>的组成：对象名、属性（状态）、操作（方法）</p><p><strong>消息</strong>：对象之间进行通信的一种构造，例：向对象发送消息 → 对象名.方法名(参数)</p><p><strong>封装</strong>：是一种信息隐藏技术，其目的是使对象的使用者和生产者分离</p><p><strong>多态</strong>：不同的对象收到同一消息可以产生完全不同的结果</p><ul><li>通用的<ul><li>参数多态：应用比较广泛，称为最纯的多态</li><li>包含多态：子类型化，即一个类型是另一个类型的子类型</li></ul></li><li><p>特定的</p><ul><li>过载多态：同一个名字在不同的上下文中所代表的含义不同</li><li>强制多态：强制类型转换</li></ul></li><li><p>静态绑定：编译时进行</p></li><li>动态绑定：运行时进行</li></ul><p>面向对象设计的原则：</p><ol><li><strong>单一责任原则</strong>：仅有一个引起它变化的原因</li><li><strong>开放-封闭原则</strong>：可拓展的（开放），不可修改的（封闭）</li><li><strong>里氏替换原则</strong>：任何基类（父类）出现的地方，子类一定可以出现</li><li><strong>依赖倒置原则</strong>：依赖于抽象，而不依赖于细节（实现） → 面向接口编程</li><li><strong>接口分离原则</strong>：依赖于抽象，不依赖于具体</li><li>共同封闭原则：一个变化若对一个包产生影响，则对该包中所有类产生影响，而其他包不受影响</li><li>共同重用原则：如果重用了包中的一个类，就要重用包中的所有类</li></ol><p>面向对象分析：</p><ol><li>认定对象</li><li>组织对象</li><li>描述对象间的相互作用</li><li>确定对象的操作</li><li>定义对象的内部信息</li></ol><p>面向对象设计的活动：</p><ol><li>识别类及对象</li><li>定义属性</li><li>定义服务</li><li>识别关系</li><li>识别包</li></ol><p>面向对象测试的 4 个层次：</p><ol><li>算法层</li><li>类层</li><li>模板层</li><li>系统层</li></ol><blockquote><ul><li><p>面向对象分析侧重于理解问题</p></li><li><p>面向对象设计侧重于理解解决方案</p></li></ul></blockquote><p>面向对象程序设计：选择合适的面向对象程序设计语言</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-数据库</title>
      <link href="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="3-数据库-软件设计师"><a href="#3-数据库-软件设计师" class="headerlink" title="3. 数据库 - 软件设计师"></a>3. 数据库 - 软件设计师</h2><p>两个实体型之间的联系：</p><ul><li>一对一联系（$1:1$）</li><li>一对多联系（$1:n$）</li><li>多对多联系（$m:n$）</li></ul><p>关系模型：采用二维表格结构表达实体类型及实体间联系的数据模型</p><p>属性：</p><ol><li>简单属性和复合属性<ul><li>复合属性可以拆分成多个属性</li></ul></li><li>单值属性和多值属性<ul><li>多值属性可能对应一组值：职工可能有多个亲属</li></ul></li><li>NULL 属性<ul><li>表示某个属性上没有值或属性值未知</li></ul></li><li>派生属性<ul><li>派生属性可由其他属性得来：通过生日和当前时间得出年龄</li></ul></li></ol><p>概念模式 → 基本表</p><p>外模式 → 视图</p><p>内模式 → 存储文件</p><ul><li>为了保证数据的<strong>物理独立性</strong>，需要修改概念模式和内模式之间的映像</li><li>为了保证数据的<strong>逻辑独立性</strong>，需要修改外模式和概念模式之间的映像</li></ul><ol><li>关系的并：关系 R 和关系 S 的所有元组合并，再删去重复的元组，组成一个新关系</li><li>关系的差：关系 R 和关系 S 的差是由属于 R 而不属于 S 的所有元组组成的集合，即关系 R 中删去与关系 S 中相同的元组</li><li>关系的交：关系 R 和关系 S 的交是由既属于 R 又属于 S 的元组组成的集合，即在两个关系 R 与 S 中取相同的元组</li><li>笛卡尔积：两个关系相乘</li></ol><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905145050705.png" alt="image-20240905145050705" style="zoom:50%;"></p><ul><li>投影：投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系</li><li>选择：选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的诸元组</li></ul><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905151208972.png" alt="image-20240905151208972" style="zoom:50%;"></p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905151517398.png" alt="image-20240905151517398" style="zoom: 50%;"></p><ul><li><p>θ 连接：R×S 中选取属性间满足一定条件的元组（例：$R.A&lt;S.A$）</p></li><li><p>等值连接：当 θ 为 = 时，例：$R.A=R.B$</p></li><li><p>自然连接：去除重复属性的等值连接，没有重复属性时连接结果为空集，例：</p><ul><li>$R_1(ABC)⋈R_2(ED)⋈R_3(ACE)→R_1⋈R_3=ABCE→ABCE⋈R_2=ABCDE$</li><li>$R_1(AC)⋈R_2(ED)⋈R_3(B)→(R_1⋈R_3=\varnothing)⋈R_2=\varnothing$</li></ul><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905164614610.png" alt="image-20240905164614610"></p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905164832564.png" alt="image-20240905164832564"></p></li></ul><blockquote><p>SQL 语言：</p><ul><li>投影 <em>π</em> → select</li><li>选择 σ → where</li><li>笛卡尔积 R×S → from R,S</li><li>自然连接 ⋈ → where R.A=S.A and R.B=S.B</li></ul><p>当 R 和 S 都进行了筛选时，查询效率最高：</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240905211654207.png" alt="image-20240905211654207" style="zoom:50%;"></p></blockquote><p>属性闭包计算：</p><p>给定关系模式 <script type="math/tex">R<U,F>，U=\{A,B,C\}，F=\{AB→C,C→B\}</script>。</p><p>关系<strong>R</strong>有 2 个候选关键字 AC 和 AB，且分别有 0 个非主属性和 3 个主属性</p><blockquote><p>解题：</p><ul><li>在<strong>F</strong>中，B 和 C 是被决定的，而 A 不能被任何属性决定，所以先确定候选关键字包含 A</li><li>$(AC)^+→(ACB)=U$ $(AB)^+→(ABC)=U$</li><li>包含在候选关键字中的就是主属性，即 A、B、C</li></ul></blockquote><p>候选码：关系中的一个属性或属性组的值能够唯一地标识一个元组，且它的子集不能唯一的标识一个元组</p><ol><li><p>部分函数依赖：依赖于候选码（多个属性组成）中的一个，例：</p><ul><li>$(a,b)→c$ 是完全函数依赖，候选码为$(a,b)$</li><li>$a→d$ ，$a→e$ 为部分函数依赖，因为非主属性 d 和 e 依赖于候选码的一部分 $(a)$</li><li>当候选码是单个属性时，可以确定没有部分函数依赖</li></ul></li><li><p>传递函数依赖：</p><ul><li>通过 $a→b$，$b→c$ 推出 $a→c$</li><li>伪传递率：若$X→Y$，$(W,Y)→Z$，则有$(X,W)→Z$</li></ul></li></ol><ul><li><p>第一范式（1NF）：R 中每一个属性是不可分割的数据项</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240908161703101.png" alt="image-20240908161703101"></p><blockquote><p>1NF 不能排除数据冗余和更新异常等问题，因为其中可能存在部分函数依赖</p></blockquote></li><li><p>第二范式（2NF）：R 是 1NF，且每个非主属性都完全函数依赖于候选码</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240908163223773.png" alt="image-20240908163223773"></p><blockquote><p>2NF 也可能存在数据冗余和更新异常等问题，因为其中可能存在传递函数依赖</p></blockquote></li><li><p>第三范式（3NF）：R 是 2NF，且每个非主属性都非传递函数依赖于候选码</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240908164736281.png" alt="image-20240908164736281"></p><blockquote><p>3NF 的关系模式 R 可能存在主属性对码的部分依赖和传递依赖</p></blockquote></li><li><p>BC 范式（BCNF）：当且仅当 F 中每个依赖的决定因素必定包含 R 的某个候选码</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有的主属性对每一个不包含它的码，也是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul><blockquote><p>一个满足 BCNF 的关系模式 R 已消除了插入和删除异常</p></blockquote></li><li><p>第四范式（4NF）：消除多值依赖</p></li></ul><p>例题：</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240908224339514.png" alt="image-20240908224339514" style="zoom:50%;"></p><blockquote><p>解题思路：</p><ol><li><p>$A_1,A_2,A_4,A_6$ 出现在 → 右边，$A_3,A_5$ 没有被任何属性决定，因此候选码包含$A_3A_5$，结合选项可知选 C（可由$A_3A_5$通过 F 验证是否能推出 R）</p></li><li><p>检查是否存在某个非主属性（$A_1,A_2,A_4,A_6$）依赖于候选码的单个属性（$A_3或A_5$）：</p><ul><li>$A_3→{}?$</li><li>$A_5→{}?$</li></ul><p>通过 F 可知不存在上述情况（部分函数依赖），满足 2NF</p></li><li><p>由$A_3A_5→A_6$（$X→Y$）和$A_5A_6→A_1$（$WY→Z$）可以推出$A_3A_5→A_1$（$XW→Z$）</p><ul><li>$A_5(A_3A_5)→A_1$去除重复的$A_5$</li></ul><p>此时根据$A_3A_5→A_1$和$A_1→A_2$可知存在传递函数依赖，不满足 3NF</p></li></ol></blockquote><ul><li><strong>1NF (第一范式)：</strong><ul><li>目的：消除重复组。</li><li>要求：确保表中的每一列都是原子的，即不可再分的最小单位。</li><li>解决的问题：重复字段组，如地址、电话号码等。</li></ul></li><li><strong>2NF (第二范式)：</strong><ul><li>前提：已经满足 1NF。</li><li>目的：进一步减少数据冗余，确保非主键列完全依赖于整个主键。</li><li>要求：在没有复合主键的情况下，所有的非主键列都必须完全依赖于单一的主键，而不是主键的一部分。</li><li>解决的问题：部分依赖导致的数据冗余。</li></ul></li><li><strong>3NF (第三范式)：</strong><ul><li>前提：已经满足 2NF。</li><li>目的：消除非主键列之间的传递依赖。</li><li>要求：非主键列不能依赖于其他非主键列，而只能直接依赖于主键。</li><li>解决的问题：由于传递依赖导致的数据冗余和更新异常。</li></ul></li><li><strong>4NF (第四范式)：</strong><ul><li>前提：已经满足 3NF。</li><li>目的：消除非平凡的多值依赖。</li><li>要求：除了候选键之外，不存在其他依赖于整个候选键的多值集合。</li><li>解决的问题：多值依赖，即一个非主键列的值集依赖于另一个非主键列的值集，而不是直接依赖于主键。</li></ul></li></ul><p>数据库设计：用户需求分析 → 概念设计 → 逻辑设计 → 物理设计</p><ol><li><p>需求分析：需求说明文档、数据字典、数据流程图</p></li><li><p>概念结构设计：属性冲突、命名冲突、结构冲突</p></li><li><p>逻辑结构设计：</p><ul><li><p>E-R 图关系模式转换</p><p><img src="/2024/11/28/3-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240910122313417.png" alt="image-20240910122313417" style="zoom:50%;"></p></li></ul></li><li><p>物理设计</p></li></ol><p>封锁：</p><ul><li>排他锁：事务 T 对数据对象 A 加上排他锁，则其他事务都不能再对 A 加任何类型的锁</li><li>共享锁：事务 T 对数据对象 A 加上共享锁，则其他事务只能再对 A 加共享锁</li></ul><p>分布式数据库：</p><ul><li><strong>分片</strong>透明：指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的</li><li><strong>复制</strong>透明：指采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的。</li><li><strong>位置</strong>透明：指用户无须知道数据存放的物理位置</li><li><strong>逻辑</strong>透明：指用户或应用程序无需知道局部场地使用的是哪种数据模型</li><li><strong>共享</strong>性：指数据存储在不同的结点数据共享</li><li><strong>自治</strong>性：指每结点对本地数据都能独立管理</li><li><strong>可用</strong>性：指当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪</li><li><strong>分布</strong>性：指数据在不同场地上的存储</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-知识产权</title>
      <link href="/2024/11/26/2-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/"/>
      <url>/2024/11/26/2-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="2-知识产权-软件设计师"><a href="#2-知识产权-软件设计师" class="headerlink" title="2. 知识产权 - 软件设计师"></a>2. 知识产权 - 软件设计师</h2><ul><li>工业产权（专利、商标）</li><li>著作权（不限期）<ul><li>人身权（发表权、署名权、修改权、保护作品完整权）</li><li>财产权</li></ul></li></ul><p>计算机软件著作权：《中华人民共和国著作权法》和《计算机软件保护条例》</p><ul><li>计算机程序：源程序、目标程序</li><li>计算机软件的文档：程序设计说明书、流程图、用户手册等</li></ul><p>职务软件作品，受雇人员享有署名权，企业公司享有著作权</p><p>委托开发软件著作权的归属：</p><ul><li>根据签订书面合同约定</li><li>若无合同，则著作权由受委托人享有</li></ul><p>商业秘密权：对软件的技术信息、经营信息提供保护</p><p>专利权：有两人以上时，先申请人先获得；若同时申请，则协商确定一个</p><p>商标权：保护期限可以延长</p><p>商标注册：先注册先得；同一天注册，先使用先得，若都没使用过则协商</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 知识产权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-计算机系统</title>
      <link href="/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机系统-软件设计师"><a href="#1-计算机系统-软件设计师" class="headerlink" title="1. 计算机系统 - 软件设计师"></a>1. 计算机系统 - 软件设计师</h2><p>计算机的基本硬件系统组成：</p><ul><li><strong>运算器</strong></li><li><strong>控制器</strong></li><li>存储器</li><li>输入设备</li><li>输出设备</li></ul><p>CPU 的功能：</p><ol><li>程序控制</li><li>操作控制</li><li>时间控制</li><li>数据处理</li></ol><blockquote><p>1、2、3 属于控制器，4 属于运算器</p></blockquote><p>运算器的组成：</p><ol><li><strong>算术逻辑单元（ALU）</strong>：实现算术运算、逻辑运算</li><li><strong>累加寄存器（AC）</strong>：存放操作数或运算结果</li><li>数据缓冲寄存器（DR）</li><li>状态条件寄存器（PSW）</li></ol><p>控制器的组成：</p><ol><li>指令寄存器（IR）：存放当前执行的指令</li><li><strong>程序计数器（PC）</strong>：存放下一条执行指令的地址，有自动加 1 功能</li><li>地址寄存器（AR）</li><li>指令译码器（ID）</li></ol><p>$指令 = 操作码 + 地址码$</p><p>存储器：寄存器 → Cache（高速缓冲存储器） → 主存（内存） → 辅存 → 外存</p><blockquote><p>速度快 → 慢，容量小 → 大，价格高 → 低</p></blockquote><p>计算机基本单位：</p><div class="table-container"><table><thead><tr><th style="text-align:center">单位</th><th style="text-align:center">表示</th><th style="text-align:center">转换</th></tr></thead><tbody><tr><td style="text-align:center">位（比特）</td><td style="text-align:center">bit / b</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节</td><td style="text-align:center">byte / B</td><td style="text-align:center">1B=8b</td></tr><tr><td style="text-align:center">千字节</td><td style="text-align:center">KB</td><td style="text-align:center">1KB=1024B</td></tr><tr><td style="text-align:center">兆字节</td><td style="text-align:center">MB</td><td style="text-align:center">1MB=1024KB</td></tr><tr><td style="text-align:center">吉字节</td><td style="text-align:center">GB</td><td style="text-align:center">1GB=1024MB</td></tr><tr><td style="text-align:center">太字节</td><td style="text-align:center">TB</td><td style="text-align:center">1TB=1024GB</td></tr></tbody></table></div><blockquote><p>最小的数据单位：bit</p><p>最小的存储单位：byte</p></blockquote><p>进制转换：</p><ul><li>二进制（B）：0 ~ 1 八进制（O）：0 ~ 7 十进制（D）：0 ~ 9 十六进制（H）：0 ~ 15</li></ul><ol><li><p>按权展开求和（n 进制 → 十进制）</p><script type="math/tex; mode=display">110_{(B)}=1\times2^2+1\times2^1+0\times2^0=6_{(D)}</script></li><li><p>除 n 取余法（十进制 → n 进制）</p><p><img src="/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20240908103656921.png" alt="image-20240908103656921" style="zoom:50%;"></p></li><li><p>八进制和十六进制转二进制</p><p><img src="/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20240908104640678.png" alt="image-20240908104640678" style="zoom:50%;"></p></li></ol><ul><li><p>原码：最高位是符号位，0 表示正号，1 表示负号，其余位表示数值的绝对值；数值 0 的原码表示有两种形式：<script type="math/tex">[+0]_原=00000000</script>，<script type="math/tex">[-0]\_原=10000000</script></p></li><li><p>反码：最高位同原码，正数的反码与其原码相同，负数的反码是除符号位外按位求反；数值 0 的反码表示有两种形式：<script type="math/tex">[+0]_反=00000000</script>，<script type="math/tex">[-0]_反=11111111</script></p></li><li>补码：最高位同原码，正数的补码与其原码和反码相同，负数的补码等于其反码末位加 1；数值 0 的补码为：<script type="math/tex">[+0]_补=00000000</script></li><li>移码：在补码的基础上，将符号位取反；数值 0 的移码为：<script type="math/tex">[+0]_移=10000000</script></li></ul><blockquote><p>一个数的补码的补码是其原码，即<script type="math/tex">[[x]_补]_补=[x]_原</script></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">码制</th><th style="text-align:center">定点整数</th><th style="text-align:center">定点小数</th></tr></thead><tbody><tr><td style="text-align:center">原码</td><td style="text-align:center">$-(2^{n-1}-1)\sim+(2^{n-1}-1)$</td><td style="text-align:center">$-(1-2^{-(n-1)})\sim+(1-2^{-(n-1)})$</td></tr><tr><td style="text-align:center">反码</td><td style="text-align:center">$-(2^{n-1}-1)\sim+(2^{n-1}-1)$</td><td style="text-align:center">$-(1-2^{-(n-1)})\sim+(1-2^{-(n-1)})$</td></tr><tr><td style="text-align:center">补码</td><td style="text-align:center">$-2^{n-1}\sim+(2^{n-1}-1)$</td><td style="text-align:center">$-1\sim+(1-2^{-(n-1)})$</td></tr><tr><td style="text-align:center">移码</td><td style="text-align:center">$-2^{n-1}\sim+(2^{n-1}-1)$</td><td style="text-align:center">$-1\sim+(1-2^{-(n-1)})$</td></tr></tbody></table></div><p>浮点数：$N=2^E\times{F}$，E 称为阶码，F 称为尾数</p><p><img src="/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20240908111351970.png" alt="image-20240908111351970" style="zoom:50%;"></p><blockquote><p>对阶，小阶向大阶对齐，浮点数</p></blockquote><p>寻址速度：立即寻址 → 寄存器寻址 → 直接寻址 → 寄存器间接寻址 → 间接寻址（从快到慢）</p><p>奇偶校验码：由 1 位奇偶校验位和 n 位有效信息位组成</p><ul><li>奇校验码：整个校验码（有效信息位和校验位）中 “1” 的个数为奇数</li><li>偶校验码：整个校验码（有效信息位和校验位）中 “1” 的个数为偶数</li></ul><p>海明校验码：</p><ul><li>码距 = 3，可以检错和<strong>纠错</strong></li><li>数据位是 n 位，校验位是 k 位，则满足：$2^k-1\geq{n+k}$</li></ul><p>循环冗余校验码：</p><ul><li>可以检错，但<strong>不能纠错</strong>，码距 = 2</li><li>在求 CRC 编码时，采用<strong>模 2 运算</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RISC</th><th style="text-align:center">CISC</th></tr></thead><tbody><tr><td style="text-align:center">指令种类</td><td style="text-align:center">少、精简</td><td style="text-align:center">多、丰富</td></tr><tr><td style="text-align:center">指令复杂度</td><td style="text-align:center">低（简单）</td><td style="text-align:center">高（复杂）</td></tr><tr><td style="text-align:center">指令长度</td><td style="text-align:center">固定</td><td style="text-align:center">变化</td></tr><tr><td style="text-align:center">寻址方式</td><td style="text-align:center">少</td><td style="text-align:center">复杂多样</td></tr><tr><td style="text-align:center">实现（译码）方式</td><td style="text-align:center">硬布线控制逻辑（组合逻辑控制器）</td><td style="text-align:center">微程序控制技术</td></tr><tr><td style="text-align:center">通用寄存器数量</td><td style="text-align:center">多、大量</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">流水线技术</td><td style="text-align:center">必须实现</td><td style="text-align:center">通过一定方式实现</td></tr></tbody></table></div><blockquote><p>指令在一个时钟周期内完成</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">x</th><th style="text-align:center">y</th><th style="text-align:center">逻辑与</th><th style="text-align:center">逻辑或</th><th style="text-align:center">逻辑异或</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><blockquote><p><strong>逻辑与</strong>：都为 1 则结果为 1，否则为 0</p><p><strong>逻辑或</strong>：都为 0 则结果为 0，否则为 1</p><p><strong>逻辑异或</strong>：相同为 0，不同为 1</p></blockquote><p>流水线公式：</p><p>$第1条指令的执行时间+(n-1)\times(最长段的时间)$</p><p><img src="/2024/11/26/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20240908113911707.png" alt="image-20240908113911707" style="zoom:50%;"></p><blockquote><p>例：上图中，到 T3 时利用率才为 100%，且有第一次输出，所以第一条指令的执行时间为$I_1+C_1+O_1=0.1+0.2+0.3=0.6$（取每时段最长时间），$n-1$为剩余指令数</p><p>故结果为$(0.1+0.2+0.3)+(n-1)\times{0.6}$</p></blockquote><p>加速比：$不采用流水线\div采用流水线$</p><p>操作周期：$最长时间段$</p><p>吞吐率：$\frac{1}{最长时间段}$</p><p>执行 n 条指令的吞吐率：$\frac{n}{流水线公式结果}$</p><p>Cache 地址映像：</p><ul><li>直接映像（冲突多）</li><li>全相联映像（冲突少）</li><li>组相联映像（冲突较少）</li></ul><blockquote><p><strong>Cache 和 主存 的映射是由硬件进行完成的</strong></p></blockquote><ul><li>中断向量：提供中断服务程序的入口地址</li><li>中断响应时间：从发出中断请求到开始进入中断处理程序</li><li>保存现场：返回去继续执行原程序</li></ul><p>输入输出（I/O）控制方式：</p><ol><li><p>程序查询方式</p><p>①<strong>CPU 和 I/O（外设）只能串行工作</strong><br>CPU 需要一直轮询检查，长期处于忙等状态</p><p>② 一次只能读/写一个字</p><p>③ 由 CPU 将数据放入内存</p><p>④CPU 利用率低</p></li><li><p>中断驱动方式</p><p>①I/O 设备通过中断信号主动报告 I/O 操作已完成</p><p>②<strong>CPU 和 I/O（外设）可并行工作</strong></p><p>③CPU 利用率得到提升</p><p>④ 由 CPU 将数据放入内存</p></li><li><p>直接存储器方式（DMA）</p><p>①<strong>CPU 和 I/O（外设）可并行工作</strong></p><p>②<strong>仅在传送数据块的开始和结束时才需要 CPU 的干预</strong></p><p>③<strong>由外设直接将数据放入内存</strong></p><p>④ 一次读写的单位为 “块” 而不是字</p></li></ol><p>总线：数据总线、地址总线、控制总线</p><p>PCI 总线 → 内总线，并行传输；SCSI 总线 → 并行外总线</p><p>加密与认证技术：</p><ul><li><p>私钥 → 解密、签名</p></li><li><p>公钥 → 加密、认证</p></li><li><p>数字签名 → 验证真实性，防止假冒和否认</p></li><li>数字证书：将个人信息和公钥发给 CA 机构，CA 机构颁给用户数字证书<ul><li>数字证书用 CA 的私钥进行签名（加密）</li><li>使用 CA 的公钥验证（解密）数字证书，得到用户的公钥</li></ul></li><li>摘要：通过 Hash 算法对明文加密得到，与 <strong>接收方解密后的明文</strong> 再进行相同算法加密得到的摘要进行对比，若一致，则没有篡改</li></ul><blockquote><p>公钥可以公开，私钥不能公开</p></blockquote><p>加密算法：</p><ul><li><p>对称加密（私钥加密）算法：<br>（共享密钥加密算法）</p><ul><li>DES、3DES、IDEA、AES（分组加密）</li><li>RC-5（流密码）</li><li>RC4</li></ul><blockquote><p>加密和解密是同一把密匙，只有一把密钥</p><p>加密强度不高，但效率高；密钥分发困难</p></blockquote></li><li><p>非对称密钥（公钥加密）算法：</p><ul><li>RSA（X.509 数字证书标准）</li><li>ECC（国密 SM2 数字证书）</li><li>DSA</li></ul><blockquote><p>加密和解密不是同一把密匙（公钥和私钥）</p><p><strong>巧记：两个 SA 和一个 CC</strong></p></blockquote></li><li><p>Hash 函数</p></li><li><p>MD5 摘要算法（128 位散列值）</p></li><li><p>SHA-1 安全散列算法（160 位散列值）</p></li></ul><p>可靠性系统：</p><ul><li>串联系统：$R=R_1R_2…R_n$</li><li>并联系统：$R=1-(1-R_1)(1-R_2)…(1-R_n)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
